# Task 260126_2340 – Guide-Line Axis Scaling for 전체 탭

## 배경
- 전체 탭의 공통 슬라이더(`region_size_x`, `region_size_y`)는 모든 부위를 X/Y 축 기준으로만 스케일링합니다.
- 사용자는 지시선을 추가한 뒤 “이미지축 사용” 옵션을 켜면, 지시선(눈 중심선) 방향을 기준으로 부위를 확대/축소하길 기대합니다.
- 현재 지시선 축 정보(`GuideLinesManager.get_eye_centers_and_angle`)는 눈 탭에서만 소비되고, 전체 탭의 슬라이더 경로(`LogicMixin._apply_common_sliders → adjust_region_size`)에는 전달되지 않습니다.

## 목표
1. "이미지축 사용" 옵션이 켜져 있을 때, 전체 탭 공통 슬라이더가 지시선 축(회전) 기준으로 스케일링하도록 한다.
2. 기존 축 기반 스케일링과 완전 호환: 옵션이 꺼져 있거나 가이드 정보를 구할 수 없으면 기존 로직을 그대로 사용.
3. 선택된 부위가 눈이 아니어도 동작하도록 하되, 회전 기준 축은 지시선 각도만 공유하고 중심점은 각 부위의 바운딩 박스를 사용한다.

## 설계 요약
1. **Guide 데이터 확보**
   - `LogicMixin._apply_common_sliders`에서 슬라이더 값 계산 직후, `use_guide_line_scaling.get()`과 `guide_lines_manager.get_eye_centers_and_angle(...)`를 확인.
   - 성공 시 `(left_center, right_center, angle)` 반환. angle과 중간점 등을 축 회전에 활용.

2. **새 스케일링 경로**
   - `utils.face_morphing.adjustments`에 `adjust_region_size_with_axis`(가칭) 추가.
     - `angle` 파라미터(라디안)와 선택적 `pivot_point`를 받아, ROI를 축 회전 → 스케일 → 역회전하는 방식으로 변형.
     - 내부 단계
       1. 기존 `adjust_region_size`가 만드는 ROI/center를 얻는다.
       2. ROI 픽셀을 numpy 배열로 가져온 뒤, 좌표계를 `angle`만큼 회전시켜 axis-aligned 상태로 만든다.
       3. 회전된 좌표계에서 width/height를 `size_x`, `size_y`로 스케일.
       4. 다시 원래 좌표계로 역회전하여 캔버스에 블렌딩.
     - 가이드 축 미지정 시 angle=0 처리.
   - 성능 단순화를 위해 ROI 단위 회전은 cv2 `warpAffine` 사용.

3. **분기 적용**
   ```python
   if size_condition:
       if use_guide_axis and guide_angle is not None:
           result = adjust_region_size_with_axis(..., guide_angle, guide_center)
       else:
           result = adjust_region_size(...)
   ```
   - `guide_center`는 (left+right)/2 중점 또는 각 부위 중심.
   - 실패 시 예외 잡고 기존 함수로 폴백.

4. **옵션 연동**
   - UI는 이미 `WidgetCreatorMixin`에서 `use_guide_line_scaling` BooleanVar 및 전역 플래그 설정을 제공.
   - 전체 탭 로직은 해당 변수를 읽기만 하면 되므로 추가 UI 변경 없음.

5. **고급 모드/테셀레이션 연동**
   - `_apply_common_sliders_to_landmarks` 경로에서도 `_scale_relative` 헬퍼를 공유하여 회전-스케일-역회전 로직을 재사용.
   - Tesselation 선택 시 호출되는 `_apply_tesselation_transform`, 눈 중심/iris 업데이트 함수에 동일한 스케일 함수를 주입해 Y축 변형 차이를 유지.
   - 드래그 보존·중앙 포인트 생성 흐름은 그대로 두고, 로그(`고급모드 축스케일 비교`, `폴리곤 좌표 변화`)로 결과를 검증.

## 구현 단계
1. `LogicMixin._apply_common_sliders`
   - guide info 조회 및 bool 플래그 계산.
   - size 적용 구간에 분기 추가.
2. `adjust_region_size_with_axis` 신설
   - 기존 `adjust_region_size` 코드 재사용하면서 회전/역회전 단계만 추가.
   - 공통 코드 중복 최소화 위해 내부 helper로 ROI 추출 로직을 공용화.
3. 예외/폴백 처리
   - cv2 또는 landmarks 미사용 환경 대비: angle 존재해도 사용 불가하면 기존 함수 호출.
4. 로깅 및 디버깅 메시지
   - guide 축 적용 여부를 디버깅 로그에 남겨 문제 추적 용이.

## 검증 계획
- 기존 "이미지축 사용" OFF 상태에서 회귀 테스트: 슬라이더 결과가 기존과 동일해야 함.
- ON 상태에서 전체 탭에서 왼쪽/오른쪽 눈 선택 후 Size 조절 시 지시선 축에 따른 회전 스케일 확인.
- 코/입 등 다른 부위에도 angle이 반영되는지 시각적으로 확인.
- MediaPipe 불가 환경에서 graceful fallback 동작 확인.

## 추후 고려 사항
- 각 부위별로 서로 다른 축을 쓰고 싶을 경우, guide manager에 추가 축 계산 로직을 확장.
- 고급 모드(custom_landmarks 직접 편집) 경로에도 동일 축 로직을 적용할지 여부 검토.

## 체크리스트
- [x] **LogicMixin 분기 준비**
  - [x] `use_guide_line_scaling` 값과 guide line angle/center를 조회하는 helper 추가 (`_should_use_guide_axis`, `_get_guide_axis_angle`)
  - [x] guide 정보가 없을 때 디버그 로그 남기고 기존 로직으로 폴백하도록 가드 작성
  - [x] 선택된 부위 목록을 loop할 때 guide 축 적용 여부를 플래그로 전달 (일반/고급 모드 공통)
- [x] **축 기준 스케일링 함수 구현**
  - [x] `adjust_region_size_with_axis` 초안 작성 (ROI 추출 → 회전 → 스케일 → 역회전)
  - [x] 기존 `adjust_region_size`와 공통되는 ROI 계산/블렌딩 코드를 helper로 분리해 중복 제거
  - [x] angle=0 또는 size 비율 기본값인 경우 즉시 기존 함수로 폴백하도록 최적화
  - [ ] unit test 또는 스크립트로 좌/우 눈, 코, 입 사례 검증 (수동 검증 진행 중)
- [x] **예외 및 폴백 경로 검증**
  - [x] MediaPipe/랜드마크 감지 실패 시 기존 축 로직으로 안전하게 되돌아가는지 확인
  - [x] cv2 없는 환경이나 warpAffine 실패 시 사용자에게 경고 로그 출력
  - [ ] blend_ratio, 중심 오프셋 등 기존 파라미터가 그대로 적용되는지 비교 스크린샷 수집
- [x] **UI/옵션 동기화**
  - [x] "이미지축 사용" 체크박스 상태가 LogicMixin 경로까지 전파되는지 이벤트 흐름 재확인
  - [x] GuideLinesManager 강제 플래그/전역 플래그와 충돌 없는지 검증
  - [ ] 지시선이 비활성화된 상태에서 옵션을 켜더라도 문제가 없는지 QA
- [ ] **고급 모드/Tesselation 반영**
  - [x] `_apply_tesselation_transform`와 `_scale_relative`를 연결해 전체 얼굴 스케일도 회전 축으로 보정
  - [x] `_calculate_and_update_iris_center` 등 중앙 포인트 계산 경로에 동일 스케일 함수를 적용
  - [ ] 이미지축 ON/OFF 비교를 통한 시각적 회귀 테스트 (max_y_diff 로그 포함)
