# 랜드마크 영역만 처리하도록 성능 최적화

**작성 일시**: 2026-01-19 23:39  
**작업 목적**: `morph_face_by_polygons` 함수에서 전체 이미지 대신 랜드마크 영역만 처리하도록 최적화하여 성능 대폭 향상

## 문제 분석

### 현재 문제점

**문제**: 전체 이미지의 모든 픽셀을 처리하여 불필요한 연산 발생

**현재 동작**:
1. 500줄: 빈 이미지로 시작 (`np.zeros`)
2. 530-542줄: 전체 이미지의 모든 픽셀 처리
   ```python
   y_coords_orig, x_coords_orig = np.mgrid[0:working_height, 0:working_width]
   ```
   - 이미지의 모든 픽셀에 대해 삼각형을 찾고 변환 적용
3. 790-806줄: 빈 공간을 원본 이미지로 채움

**영향**:
- 랜드마크 영역 밖의 픽셀도 처리하여 불필요한 연산 발생
- 성능 저하의 주요 원인
- 예: 2000x3000 이미지에서 얼굴 영역이 500x600인 경우, 불필요한 픽셀 처리량이 약 10배

## 작업 계획

### 1. 랜드마크 바운딩 박스 계산 함수 추가

**위치**: `utils/face_morphing/polygon_morphing/core.py`

**기능**:
- 원본 및 변형된 랜드마크의 바운딩 박스 계산
- 패딩 추가 (변형 시 영역 확장 고려)
- 이미지 경계 내로 제한

**구현**:
```python
def _calculate_landmark_bounding_box(landmarks, img_width, img_height, padding_ratio=0.2):
    """랜드마크 바운딩 박스 계산
    
    Args:
        landmarks: 랜드마크 포인트 리스트
        img_width: 이미지 너비
        img_height: 이미지 높이
        padding_ratio: 패딩 비율 (기본 30%, 변형 시 확장 고려)
    
    Returns:
        (min_x, min_y, max_x, max_y): 바운딩 박스 좌표
    """
    if not landmarks:
        return None
    
    # 랜드마크 좌표 추출
    x_coords = [pt[0] for pt in landmarks if isinstance(pt, tuple)]
    y_coords = [pt[1] for pt in landmarks if isinstance(pt, tuple)]
    
    if not x_coords or not y_coords:
        return None
    
    min_x = max(0, int(min(x_coords)))
    min_y = max(0, int(min(y_coords)))
    max_x = min(img_width, int(max(x_coords)))
    max_y = min(img_height, int(max(y_coords)))
    
    # 패딩 추가 (변형 시 영역 확장 고려)
    width = max_x - min_x
    height = max_y - min_y
    padding_x = int(width * padding_ratio)
    padding_y = int(height * padding_ratio)
    
    min_x = max(0, min_x - padding_x)
    min_y = max(0, min_y - padding_y)
    max_x = min(img_width, max_x + padding_x)
    max_y = min(img_height, max_y + padding_y)
    
    return (min_x, min_y, max_x, max_y)
```

### 2. 바운딩 박스 기반 픽셀 필터링 및 크기 최적화

**위치**: `utils/face_morphing/polygon_morphing/core.py` (460줄, 530줄 근처)

**변경 내용**:
- 전체 이미지 대신 바운딩 박스 영역만 처리
- 다운샘플링 판단을 바운딩 박스 크기 기준으로 변경 (전체 이미지 크기 대신)
- 삼각형 찾기 범위를 바운딩 박스로 제한
- 픽셀 좌표 생성 시 바운딩 박스 내부만 포함

**구현**:
```python
# 랜드마크 바운딩 박스 계산 (원본 이미지 크기 기준)
bbox_orig = _calculate_landmark_bounding_box(original_landmarks_no_iris, img_width, img_height)
bbox_trans = _calculate_landmark_bounding_box(transformed_landmarks_no_iris, img_width, img_height)

# 두 바운딩 박스를 합쳐서 처리 영역 결정 (변형 시 확장 고려)
if bbox_orig and bbox_trans:
    min_x = min(bbox_orig[0], bbox_trans[0])
    min_y = min(bbox_orig[1], bbox_trans[1])
    max_x = max(bbox_orig[2], bbox_trans[2])
    max_y = max(bbox_orig[3], bbox_trans[3])
    
    # 바운딩 박스 크기 계산
    bbox_width = max_x - min_x
    bbox_height = max_y - min_y
    bbox_max_dimension = max(bbox_width, bbox_height)
    
    # 바운딩 박스 크기를 기준으로 다운샘플링 판단
    # 랜드마크 영역만 처리하므로 작게 설정해도 됨 (얼굴 영역은 보통 500-800px)
    # 패딩 포함해도 600-1000px 정도이므로 800-1000으로 설정해도 대부분 원본 해상도 유지
    max_dimension = 1000  # 랜드마크 영역만 처리하므로 작게 설정해도 충분
    scale_factor = 1.0
    working_img = img_array
    working_width = img_width
    working_height = img_height
    
    if bbox_max_dimension > max_dimension:
        # 바운딩 박스가 max_dimension보다 크면 다운샘플링
        scale_factor = max_dimension / bbox_max_dimension
        # 전체 이미지는 원본 크기 유지, 바운딩 박스만 스케일 조정
        # (실제로는 전체 이미지를 다운샘플링하되, 바운딩 박스 영역만 처리)
        working_width = int(img_width * scale_factor)
        working_height = int(img_height * scale_factor)
        working_img = cv2.resize(img_array, (working_width, working_height), interpolation=cv2.INTER_LINEAR)
        
        # 랜드마크 좌표도 스케일 조정
        original_points_array_scaled = original_points_array * scale_factor
        transformed_points_array_scaled = transformed_points_array * scale_factor
        
        # 스케일된 좌표로 Delaunay 재계산
        tri_scaled = Delaunay(original_points_array_scaled)
        tri = tri_scaled
        original_points_array = original_points_array_scaled
        transformed_points_array = transformed_points_array_scaled
        
        # 바운딩 박스도 스케일 조정
        min_x = int(min_x * scale_factor)
        min_y = int(min_y * scale_factor)
        max_x = int(max_x * scale_factor)
        max_y = int(max_y * scale_factor)
else:
    # 바운딩 박스 계산 실패 시 전체 이미지 사용 (폴백)
    min_x, min_y = 0, 0
    max_x, max_y = working_width, working_height
    # 기존 로직 유지 (전체 이미지 크기 기준)

# 바운딩 박스 영역만 처리
bbox_height = max_y - min_y
bbox_width = max_x - min_x

# 바운딩 박스 내부 픽셀 좌표만 생성
y_coords_orig, x_coords_orig = np.mgrid[min_y:max_y, min_x:max_x]
pixel_coords_orig = np.column_stack([x_coords_orig.ravel(), y_coords_orig.ravel()])
```

### 3. 결과 이미지에 원본 이미지 복사

**위치**: `utils/face_morphing/polygon_morphing/core.py` (500줄, 790줄 근처)

**변경 내용**:
- 결과 이미지를 원본 이미지로 초기화 (빈 이미지 대신)
- 바운딩 박스 영역만 변환 적용
- 나머지 영역은 원본 이미지 유지

**구현**:
```python
# 결과 이미지 초기화 (원본 이미지로 시작)
result = working_img.copy().astype(np.float32)
result_count = np.ones((working_height, working_width), dtype=np.float32)  # 원본은 이미 1로 설정

# 바운딩 박스 영역만 처리
# ... (바운딩 박스 내부 픽셀만 변환)
```

### 4. 좌표 오프셋 처리

**위치**: `utils/face_morphing/polygon_morphing/core.py` (픽셀 처리 부분)

**변경 내용**:
- 바운딩 박스 오프셋을 고려하여 좌표 변환
- 결과 이미지에 매핑할 때 오프셋 적용

**구현**:
```python
# 바운딩 박스 내부 픽셀 좌표 (전역 좌표)
pixel_coords_orig_global = np.column_stack([x_coords_orig.ravel(), y_coords_orig.ravel()])

# 삼각형 찾기 (전역 좌표 사용)
simplex_indices_orig = tri.find_simplex(pixel_coords_orig_global)

# 결과 이미지에 매핑할 때는 전역 좌표 그대로 사용
# (result는 전체 이미지 크기이므로)
```

### 5. 삼각형 필터링 최적화 (추가)

**위치**: `utils/face_morphing/polygon_morphing/core.py` (655-665줄)

**변경 내용**:
- 바운딩 박스와 겹치는 삼각형만 처리하도록 필터링
- 모든 삼각형을 순회하는 대신 실제로 사용된 삼각형만 처리

**구현**:
```python
# 성능 최적화: 바운딩 박스와 겹치는 삼각형만 처리
# simplex_indices_orig에서 실제로 사용된 삼각형 인덱스만 추출
valid_simplex_indices = np.unique(simplex_indices_orig[simplex_indices_orig >= 0])

# 바운딩 박스와 겹치는 삼각형만 순회 (성능 최적화)
for simplex_idx in valid_simplex_indices:
    simplex = tri.simplices[simplex_idx]
    # ... 기존 처리 로직 ...
```

**효과**:
- 이전: 모든 삼각형 순회 (200-300개)
- 변경 후: 바운딩 박스와 겹치는 삼각형만 처리 (50-100개)
- 예상 성능 향상: 약 3-4배 추가 향상

### 6. 바운딩 박스 캐싱 최적화 (추가)

**위치**: `gui/face_edit/landmark_manager.py`, `utils/face_morphing/polygon_morphing/core.py`

**변경 내용**:
- 원본 랜드마크 바운딩 박스를 이미지 로딩 시 한 번만 계산하여 캐싱
- `morph_face_by_polygons` 호출 시 캐시된 바운딩 박스 사용

**구현**:
```python
# LandmarkManager에 바운딩 박스 캐싱 추가
def set_original_bbox(self, bbox, img_width, img_height):
    self._original_bbox = bbox
    self._original_bbox_img_size = (img_width, img_height)

def get_original_bbox(self, img_width, img_height):
    # 이미지 크기 검증 후 캐시된 바운딩 박스 반환
    return self._original_bbox

# morph_face_by_polygons에 캐시된 바운딩 박스 전달
cached_bbox = self.landmark_manager.get_original_bbox(img_width, img_height)
result = face_morphing.morph_face_by_polygons(..., cached_original_bbox=cached_bbox)
```

**효과**:
- 이전: `morph_face_by_polygons` 호출마다 원본 바운딩 박스 재계산
- 변경 후: 이미지 로딩 시 한 번만 계산, 이후 캐시 사용
- 예상 성능 향상: 바운딩 박스 계산 시간 제거

### 7. 업샘플링 최적화 (추가)

**위치**: `utils/face_morphing/polygon_morphing/core.py` (953-975줄)

**변경 내용**:
- 전체 이미지 업샘플링 대신 바운딩 박스 영역만 업샘플링
- 나머지 영역은 원본 이미지 사용

**구현**:
```python
# 바운딩 박스 영역만 업샘플링 (전체 이미지 업샘플링 대신)
if scale_factor < 1.0 and min_x_orig_bbox is not None:
    result_full = img_array.copy().astype(np.float32)
    bbox_result = result[min_y:max_y, min_x:max_x].copy()
    bbox_result_upscaled = cv2.resize(bbox_result, (bbox_width_orig, bbox_height_orig), interpolation=cv2.INTER_LINEAR)
    result_full[min_y_orig:max_y_orig, min_x_orig:max_x_orig] = bbox_result_upscaled.astype(np.float32)
    result = result_full
```

**효과**:
- 이전: 전체 이미지 업샘플링 (2000x3000 = 6,000,000 픽셀)
- 변경 후: 바운딩 박스 영역만 업샘플링 (500x600 = 300,000 픽셀)
- 예상 성능 향상: 약 20배 향상

### 8. 로컬 복사본 제거 최적화 (추가)

**위치**: `utils/face_morphing/polygon_morphing/core.py` (48줄), `gui/face_edit/landmark_manager.py` (151줄)

**변경 내용**:
- 바운딩 박스 계산 시 랜드마크 리스트 복사본 생성 제거
- `exclude_indices` 파라미터로 인덱스만 전달하여 필터링

**구현**:
```python
# _calculate_landmark_bounding_box에 exclude_indices 파라미터 추가
def _calculate_landmark_bounding_box(landmarks, img_width, img_height, padding_ratio=0.3, exclude_indices=None):
    exclude_set = exclude_indices if exclude_indices is not None else set()
    for i, pt in enumerate(landmarks):
        if i in exclude_set:
            continue
        # 좌표 추출 (복사본 없이)

# 바운딩 박스 계산 시 exclude_indices 사용
bbox = _calculate_landmark_bounding_box(landmarks, img_width, img_height, exclude_indices=iris_indices)
```

**효과**:
- 이전: `landmarks_no_iris = [pt for i, pt in enumerate(landmarks) if i not in iris_indices]` (복사본 생성)
- 변경 후: 인덱스만 체크하여 좌표 추출 (복사본 없음)
- 메모리 절약: 바운딩 박스 계산 시 불필요한 리스트 복사 제거

## 예상 효과

### 성능 향상

**이전**:
- 전체 이미지 처리: 2000x3000 = 6,000,000 픽셀
- 처리 시간: 전체 픽셀 수에 비례

**개선 후**:
- 랜드마크 영역만 처리: 500x600 = 300,000 픽셀 (패딩 포함)
- 바운딩 박스와 겹치는 삼각형만 처리: 약 50-100개 (전체 200-300개 중)
- 바운딩 박스 캐싱: 이미지 로딩 시 한 번만 계산
- 업샘플링 최적화: 바운딩 박스 영역만 업샘플링 (약 20배 향상)
- 처리 시간: 약 20배 향상 예상 (픽셀 수 기준) + 약 3-4배 추가 향상 (삼각형 필터링) + 업샘플링 최적화
- 총 예상 성능 향상: 약 60-80배 (픽셀 수 × 삼각형 수 최적화 × 업샘플링 최적화)

### 메모리 사용량

- 삼각형 찾기 메모리: 약 20배 감소
- 픽셀 좌표 배열: 약 20배 감소
- 삼각형 순회 메모리: 약 3-4배 감소 (필터링된 삼각형만 처리)
- 바운딩 박스 계산 메모리: 복사본 생성 제거 (exclude_indices 사용)
- 업샘플링 메모리: 바운딩 박스 영역만 처리하여 약 20배 감소

## 작업 단계

- [x] 1. 랜드마크 바운딩 박스 계산 함수 구현 ✅ (48-93줄)
- [x] 2. 바운딩 박스 기반 픽셀 필터링 적용 ✅ (504-600줄)
- [x] 3. 결과 이미지 초기화 방식 변경 (원본 이미지로 시작) ✅ (605-606줄)
- [x] 4. 좌표 오프셋 처리 구현 ✅ (638-639줄, 794-800줄)
- [x] 5. 삼각형 필터링 최적화 (바운딩 박스와 겹치는 삼각형만 처리) ✅ (655-665줄)
- [x] 6. 바운딩 박스 캐싱 최적화 (이미지 로딩 시 한 번만 계산) ✅ (landmark_manager.py, core.py)
- [x] 7. 업샘플링 최적화 (바운딩 박스 영역만 업샘플링) ✅ (953-975줄)
- [x] 8. 로컬 복사본 제거 최적화 (exclude_indices 사용) ✅ (48줄, landmark_manager.py 151줄)
- [ ] 9. 테스트 및 검증 (사용자 테스트 필요)
- [ ] 10. 성능 측정 및 비교 (사용자 측정 필요)

## 주의사항

1. **바운딩 박스 계산 실패 시**: 전체 이미지 처리로 폴백
2. **패딩 크기**: 변형 시 영역 확장을 고려하여 충분한 패딩 필요 (30%로 증가)
3. **경계 처리**: 이미지 경계를 벗어나지 않도록 제한
4. **변형된 랜드마크**: 변형 후 영역이 확장될 수 있으므로 두 바운딩 박스를 합쳐서 사용
5. **max_dimension 기준 변경**: 
   - **이전**: 전체 이미지 크기 기준 (`max(img_width, img_height)`)
   - **변경 후**: 바운딩 박스 크기 기준 (`max(bbox_width, bbox_height)`)
   - 랜드마크 영역만 처리하므로 작게 설정해도 됨 (800-1000 권장)
   - 얼굴 영역은 보통 500-800px이므로 1000으로 설정해도 대부분 원본 해상도 유지
6. **바운딩 박스 캐싱**: 이미지 크기가 변경되면 캐시 무효화
7. **로컬 복사본 제거**: 바운딩 박스 계산 시 `exclude_indices` 사용하여 복사본 생성 방지

## 완료 조건

- [x] 랜드마크 영역만 처리하도록 최적화 완료 ✅
- [ ] 성능 향상 확인 (최소 10배 이상) - 테스트 필요
- [ ] 품질 유지 (변형 결과 동일) - 테스트 필요
- [x] 경계 케이스 처리 (바운딩 박스 계산 실패 등) ✅ (565-600줄 폴백 로직)
