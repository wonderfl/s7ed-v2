# 작업계획서: GPU 가속 적용 및 성능 최적화

## 작업 목표
그래픽 카드를 활용하여 이미지 변형 처리 성능을 대폭 향상시키고, CPU 기반 Python 반복문을 벡터화하여 계산 속도를 개선합니다.

## 문제 분석
1. **CPU 기반 처리**: 현재 모든 이미지 변형 처리가 CPU에서만 수행되어 느림
2. **Python 반복문 병목**: 픽셀 단위 처리에서 Python for 루프 사용으로 매우 느림
3. **GPU 미활용**: 그래픽 카드가 있어도 활용하지 않음
4. **비효율적인 메모리 사용**: 큰 이미지를 한 번에 처리하여 메모리 부담

## 작업 계획

### 1. OpenCV CUDA 지원 확인 및 GPU 가속 적용
- **위치**: `utils/face_morphing.py` 초기화 부분 및 이미지 리사이즈
- **기능**:
  - OpenCV CUDA 지원 여부 자동 감지 (`cv2.cuda.getCudaEnabledDeviceCount()`)
  - 이미지 리사이즈를 GPU에서 처리 (CUDA 사용 가능 시)
  - GPU 실패 시 자동으로 CPU로 폴백
- **예상 효과**: 이미지 리사이즈 속도 2-5배 향상 (GPU 사용 시)

### 2. 픽셀 처리 완전 벡터화
- **위치**: `utils/face_morphing.py` `morph_face_by_polygons()` 함수 (2922줄)
- **현재 문제**: 
  - Python for 루프로 각 픽셀마다 bilinear interpolation 수행
  - 가중치 분배를 반복문으로 처리하여 매우 느림
- **개선 방안**:
  - `np.add.at()`를 사용하여 완전 벡터화
  - valid_00, valid_01, valid_10, valid_11 마스크를 사용하여 한 번에 처리
  - 범위를 벗어난 픽셀도 벡터화하여 처리
- **예상 효과**: 10-50배 성능 향상 (가장 큰 효과)

### 3. 랜드마크 차이 계산 벡터화
- **위치**: `utils/face_morphing.py` `morph_face_by_polygons()` 함수 (2741줄)
- **현재 문제**: 
  - for 루프로 각 랜드마크의 차이를 계산
- **개선 방안**:
  - NumPy 벡터 연산으로 변경 (`np.sqrt(np.sum((trans_pts - orig_pts)**2, axis=1))`)
- **예상 효과**: 약 5-10배 성능 향상

### 4. 메모리 최적화 (큰 이미지 처리)
- **위치**: `utils/face_morphing.py` `morph_face_by_polygons()` 함수 (2739줄)
- **기능**:
  - 큰 이미지는 청크 단위로 처리 (100,000 픽셀씩)
  - Delaunay Triangulation 삼각형 찾기도 청크 단위로 수행
- **예상 효과**: 메모리 사용량 감소 및 대용량 이미지 처리 가능

### 5. 불필요한 로그 제거
- **위치**: `utils/face_morphing.py` 여러 위치
- **제거할 로그**:
  - Delaunay Triangulation 생성 로그
  - 성능 최적화 이미지 크기 변경 로그
  - 랜드마크 변형 확인 로그
  - 빈 공간 감지 로그
  - 이미지 크기 복원 로그
  - 랜드마크 변형 완료 로그
- **예상 효과**: 약 5-10% 성능 향상 (로그 출력 오버헤드 제거)

## 작업 단계
- [x] 1. OpenCV CUDA 지원 확인 및 GPU 가속 적용
  - [x] 1-1. OpenCV CUDA 지원 여부 자동 감지 변수 추가
  - [x] 1-2. 이미지 리사이즈 GPU 가속 적용
  - [x] 1-3. GPU 실패 시 CPU 폴백 로직 구현
- [x] 2. 픽셀 처리 완전 벡터화
  - [x] 2-1. Python for 루프 제거
  - [x] 2-2. `np.add.at()`를 사용한 가중치 분배 벡터화
  - [x] 2-3. 범위 체크 및 범위 밖 픽셀 처리 벡터화
- [x] 3. 랜드마크 차이 계산 벡터화
  - [x] 3-1. for 루프를 NumPy 벡터 연산으로 변경
- [x] 4. 메모리 최적화
  - [x] 4-1. 청크 단위 처리 로직 추가
  - [x] 4-2. Delaunay Triangulation 삼각형 찾기 청크 처리
- [x] 5. 불필요한 로그 제거
  - [x] 5-1. 성능에 영향을 주는 디버깅 로그 제거

## 작업 완료 내역
- 2026-01-16 18:00: OpenCV CUDA 지원 확인 변수 추가 (`_cv2_cuda_available`)
- 2026-01-16 18:00: 이미지 리사이즈 GPU 가속 적용 (CUDA 사용 가능 시)
- 2026-01-16 18:00: 픽셀 처리 완전 벡터화 (`np.add.at()` 사용)
- 2026-01-16 18:00: 랜드마크 차이 계산 벡터화
- 2026-01-16 18:00: 큰 이미지 청크 단위 처리 추가
- 2026-01-16 18:00: 불필요한 로그 제거

## 예상 효과
- **전체 성능**: 약 10-50배 성능 향상 (GPU 사용 시 추가 향상)
- **가장 큰 효과**: 픽셀 처리 벡터화 (10-50배)
- **GPU 가속**: 이미지 리사이즈 2-5배 향상 (CUDA 지원 시)
- **메모리**: 대용량 이미지 처리 가능 (청크 단위 처리)

## 주의사항
- **OpenCV CUDA 지원**: 
  - 일반 `opencv-python`은 CPU만 지원
  - GPU 가속을 사용하려면 CUDA 지원 빌드 필요
  - `opencv-contrib-python` 또는 CUDA 지원 빌드 사용 권장
- **GPU 메모리**: GPU 메모리가 부족하면 자동으로 CPU로 폴백
- **호환성**: GPU가 없거나 CUDA를 지원하지 않아도 정상 작동 (CPU로 폴백)

## 구현 세부사항

### 1. OpenCV CUDA 지원 확인
```python
try:
    import cv2
    _cv2_available = True
    # OpenCV CUDA 지원 확인
    _cv2_cuda_available = cv2.cuda.getCudaEnabledDeviceCount() > 0
except ImportError:
    _cv2_available = False
    _cv2_cuda_available = False
except AttributeError:
    # OpenCV가 CUDA 지원 없이 빌드된 경우
    _cv2_cuda_available = False
```

### 2. GPU 가속 이미지 리사이즈
```python
# GPU 가속 리사이즈 시도 (CUDA 지원 시)
if _cv2_cuda_available:
    try:
        # GPU 메모리로 업로드
        gpu_img = cv2.cuda_GpuMat()
        gpu_img.upload(img_array)
        # GPU에서 리사이즈
        gpu_resized = cv2.cuda.resize(gpu_img, (working_width, working_height), interpolation=cv2.INTER_AREA)
        # CPU로 다운로드
        working_img = gpu_resized.download()
    except Exception:
        # GPU 실패 시 CPU로 폴백
        working_img = cv2.resize(img_array, (working_width, working_height), interpolation=cv2.INTER_AREA)
else:
    working_img = cv2.resize(img_array, (working_width, working_height), interpolation=cv2.INTER_AREA)
```

### 3. 픽셀 처리 벡터화
```python
# 가중치 분배 (완전 벡터화 - 성능 최적화)
# NumPy의 advanced indexing을 사용하여 벡터화
# valid_00, valid_01, valid_10, valid_11 마스크를 사용하여 한 번에 처리

# valid_00인 경우
valid_00_indices = np.where(valid_00)[0]
if len(valid_00_indices) > 0:
    y0_valid = y0[valid_00_indices]
    x0_valid = x0[valid_00_indices]
    w00_valid = w00[valid_00_indices]
    pixel_values_00 = pixel_values[valid_00_indices]
    weighted_values_00 = pixel_values_00 * w00_valid[:, np.newaxis]
    np.add.at(result, (y0_valid, x0_valid), weighted_values_00)
    np.add.at(result_count, (y0_valid, x0_valid), w00_valid)
# ... (valid_01, valid_10, valid_11도 동일하게 처리)
```

### 4. 랜드마크 차이 계산 벡터화
```python
# 변형된 랜드마크와 원본 랜드마크의 차이 확인 (벡터화)
if len(original_landmarks) > 0:
    orig_pts = original_points_array[:len(original_landmarks)]
    trans_pts = transformed_points_array[:len(original_landmarks)]
    diffs = np.sqrt(np.sum((trans_pts - orig_pts)**2, axis=1))
    max_diff = np.max(diffs)
    changed_count = np.sum(diffs > 0.1)
```

### 5. 청크 단위 처리
```python
# 메모리 효율성을 위해 청크 단위로 처리 (큰 이미지의 경우)
chunk_size = 100000  # 한 번에 처리할 픽셀 수
total_pixels = working_height * working_width

if total_pixels > chunk_size:
    # 큰 이미지는 청크 단위로 처리하여 메모리 사용량 감소
    for chunk_start in range(0, total_pixels, chunk_size):
        chunk_end = min(chunk_start + chunk_size, total_pixels)
        chunk_coords = pixel_coords_orig[chunk_start:chunk_end]
        simplex_indices_orig[chunk_start:chunk_end] = tri.find_simplex(chunk_coords)
```

## 추가 최적화 가능 항목 (향후 검토)

### 6. NumPy 대신 CuPy 사용 (선택적)
- **위치**: `utils/face_morphing.py` 전체
- **기능**: 
  - NumPy 배열을 CuPy 배열로 변경
  - 모든 NumPy 연산을 GPU에서 수행
- **예상 효과**: 5-20배 추가 성능 향상
- **주의사항**: 
  - CuPy 설치 필요 (`pip install cupy-cuda11x` 또는 `cupy-cuda12x`)
  - GPU 메모리 사용량 증가
  - CPU-GPU 간 데이터 전송 오버헤드 고려

### 7. OpenCV CUDA Warp Affine 사용
- **위치**: `utils/face_morphing.py` `morph_face_by_polygons()` 함수
- **기능**: 
  - 각 삼각형 변형을 GPU에서 수행
  - `cv2.cuda.warpAffine()` 사용
- **예상 효과**: 2-5배 추가 성능 향상
- **주의사항**: 
  - 삼각형별로 GPU 커널 호출 오버헤드
  - 작은 삼각형의 경우 오버헤드가 더 클 수 있음

### 8. 병렬 처리 (멀티스레딩)
- **위치**: `utils/face_morphing.py` 삼각형 처리 루프
- **기능**: 
  - 삼각형 처리를 여러 스레드로 분할
  - `concurrent.futures.ThreadPoolExecutor` 사용
- **예상 효과**: 멀티코어 CPU에서 2-4배 성능 향상
- **주의사항**: 
  - GIL 제약으로 인한 제한적 효과
  - 메모리 공유 및 동기화 오버헤드

## 테스트 방법

### GPU 가속 확인
```python
import cv2
print(f"CUDA 지원: {cv2.cuda.getCudaEnabledDeviceCount() > 0}")
```

### 성능 측정
- 이미지 변형 전후 시간 측정
- CPU 사용률 및 GPU 사용률 모니터링
- 메모리 사용량 확인

## 참고 자료
- OpenCV CUDA: https://docs.opencv.org/4.x/d0/d60/classcv_1_1cuda_1_1GpuMat.html
- NumPy 벡터화: https://numpy.org/doc/stable/user/basics.broadcasting.html
- CuPy: https://cupy.dev/
