# 리팩터 계획: 지시선 축 스케일링 & UI 상태

## 배경
- `_apply_common_sliders_to_landmarks` 함수가 900라인 이상으로 비대하며, 지시선 축 로직·테셀레이션·복원·로그가 뒤섞여 있음.
- UI 상태 변수(`use_guide_line_scaling` 등)가 믹스인 곳곳에 중복 정의되어 체크박스와 내부 상태가 불일치함.
- 디버그 로그가 분산되어 실제 변환 경로를 추적하기 어려움.

## 목표
1. 지시선 축 관련 상태를 단일 BooleanVar로 통합하여 UI/GuideLinesManager/모핑 로직이 동일한 값을 사용하도록 한다.
2. `_apply_common_sliders_to_landmarks` 를 작은 함수로 분할하여 책임을 명확히 한다(예: `compute_scale_factors`, `apply_region_transforms`, `restore_unselected_points`, `log_transforms`).
3. 로그·하이라이트 헬퍼를 표준화하여 변형 포인트 시각화를 일관되게 제공한다.
4. Size 슬라이더와 지시선 축 체크가 항상 일관되게 적용되도록 가드 로직을 추가한다.

## 제안 단계
1. **상태 정리**
   - BooleanVar/DoubleVar 생성은 `FaceEditPanel.__init__` 에서만 수행한다.
   - `widget_creator` 등 다른 믹스인은 기존 변수를 참조하도록 수정한다.
   - 지시선 축 토글 시 GuideLinesManager 및 전역 플래그를 동시에 업데이트하는 헬퍼를 둔다.

2. **함수 분해**
   - `_apply_common_sliders_to_landmarks` 에서 다음과 같은 서브 함수를 추출한다.
     - `should_use_guide_axis(...)`
     - `collect_selected_indices(...)`
     - `apply_tessellation_transform(...)`
     - `apply_region_transform(...)`
     - `restore_unselected(...)`
     - `prepare_polygon_data(...)`
   - 각 함수는 명시적인 입력/출력을 사용하여 숨은 상태 의존성을 줄인다.

### `_apply_common_sliders_to_landmarks` 분해 계획
1. **상태/선택 수집 블록**
   - `selected_regions` 필터링, `custom_landmarks` 방어 로직, `size/offset/position 조건` 계산을 ` _collect_landmark_transform_context()` 로 추출.
   - 산출물: {선택 영역, 조건 플래그, 가이드축 사용 여부, landmark 매니저 핸들}.
2. **테셀레이션 전용 처리**
   - `tesselation` 단독 선택 시 실행되는 그래프/확장 계산을 `_handle_tesselation_transform(...)` 로 분리.
   - 공통 스케일 함수(`scale_relative_fn`)를 인자로 받아 고급/일반 모드와 동일한 축 로직을 공유하도록 한다.
3. **비-테셀레이션 영역 처리**
   - 선택된 영역에 따라 `center_offset`·`position`·`size`를 적용하는 반복 루프를 `_transform_selected_landmarks(...)` 로 이동.
   - 가이드축 회전(`_scale_relative_for_axis`)과 기본 스케일 분기를 이 헬퍼 내부로 통합한다.
4. **복원/하이라이트 단계**
   - `_finalize_landmark_transforms(selected_regions, updated_landmarks, original_face_landmarks, original_landmarks, dragged_indices, image_size, use_guide_axis, handled_tesselation)` 형태로 추출한다.
   - 입력: 앞선 단계에서 만든 `updated_landmarks`, 원본/iris 랜드마크, 가이드축 사용 여부, 드래그된 포인트, 테셀레이션 단독 여부.
   - 처리: (1) `transformed_point_indices` 계산 로직을 일원화하고, (2) 복원 여부를 결정해 미선택 영역을 원본으로 되돌리며, (3) 복원/변형 샘플 로그를 기록하고, (4) 468/470 포인트 배열을 분기 없이 돌려준다.
   - 출력: `FinalizedLandmarks` 구조(dict)로 `final_landmarks`, `final_landmarks_for_custom`, `original_face_landmarks_tuple`, `transformed_point_indices`, `restored_samples` 등을 패키징하여 이후 단계의 입력을 명확히 한다.
5. **폴리곤/모핑 준비**
   - `_prepare_polygon_inputs(finalized, selected_regions, landmark_manager, image, blend_ratio, use_landmark_warping)` 으로 헬퍼화한다.
   - 역할: (1) iris center/원본 좌표 확보, (2) 테셀레이션과 일반 모드의 468/470 구조 차이를 흡수, (3) `selected_indices_for_morph` 계산, (4) `morph_face_by_polygons` 호출 파라미터를 한 곳에서 조립.
   - 반환값: `PolygonMorphParams` (namedtuple/dict)로 `original_for_morph`, `transformed_for_morph`, `selected_indices`, `left/right centers`, `blend_ratio`, `cached_bbox` 등을 포함하여 본 함수의 말단 코드를 단일 호출로 치환한다.

각 단계가 끝날 때마다 대응하는 체크리스트 항목에 표시하여 추후 회귀 시 파악이 쉽도록 한다.

3. **로그 & 시각화 표준화**
   - `log_transform_samples(indices, before, after)` 같은 공통 헬퍼를 만들어 반복 코드를 줄인다.
   - 한 번의 연산에서 `highlight_indices` 리스트를 유지하고 폴리곤 그리기에도 전달한다.
   - 로그를 그룹화하여 콘솔 잡음을 줄인다.

4. **검증 & 테스트**
   - 리팩터 이후, 지시선 축 ON/OFF 시나리오를 스크립트 또는 단위 테스트로 검증한다.
   - UI 체크박스 상태와 내부 BooleanVar가 항상 일치하는지 확인한다.

## 체크리스트
- [x] 상태 변수 생성 지점을 FaceEditPanel.__init__ 으로 제한한다.
- [x] `widget_creator`/슬라이더 UI가 기존 BooleanVar/DoubleVar를 재사용하도록 수정한다.
- [x] `_apply_common_sliders` 진입부를 헬퍼로 분리하여 고급/일반 흐름을 정리한다.
- [x] `_apply_common_sliders_to_landmarks` - 컨텍스트 수집 헬퍼를 도입한다.
- [x] `_apply_common_sliders_to_landmarks` - 테셀레이션 전용 헬퍼를 도입한다.
- [x] `_apply_common_sliders_to_landmarks` - 일반 영역 변환 헬퍼를 도입한다.
- [x] `_apply_common_sliders_to_landmarks` - 복원/하이라이트/폴리곤 준비 헬퍼를 도입한다.
- [x] 가이드축 ON/OFF 토글 헬퍼와 전역 플래그 동기화를 구현한다.
- [ ] 로그/하이라이트 헬퍼를 도입하고 기존 중복 로그를 대체한다.
- [ ] 리팩터 후 지시선 축 시나리오 테스트(ON/OFF, 테셀레이션 포함)를 수행한다.
- [ ] 더 이상 사용하지 않는 `FaceEditPanelV2` 관련 코드/주석을 제거한다.

## 다음 작업
- 로그/하이라이트 표준화 헬퍼를 도입하여 출력 포맷과 강조 포인트 계산을 일원화한다.
- 지시선 축 ON/OFF 및 테셀레이션 스모크 테스트 결과를 기록하고 회귀 체크리스트에 추가한다.
- 각 코드 블록의 책임/입출력을 문서화하는 워크스루를 진행한다.
- 리스크가 낮은 상태 정리부터 적용하고, 테스트/로그를 갖춘 상태에서 순차적으로 함수 분해를 진행한다.
- 새 헬퍼 API와 사용 방법을 본 문서에 지속적으로 기록한다.

## 참고: 대형 함수/모듈 목록
- `gui/face_edit/morphing/logic.py`
  - `_apply_common_sliders` (약 900+ 라인)
  - `_apply_common_sliders_to_landmarks` (약 700 라인)
- `utils/face_morphing/polygon_morphing/core.py`
  - `morph_face_by_polygons` (약 600 라인)
  - `_prepare_iris_centers` (약 250 라인)
- `gui/face_edit/polygon_renderer/drawing.py`
  - `_draw_landmark_polygons` (약 400 라인)
- 기타 후보: `all_tab_drawer._draw_all_tab_polygons`, `tab_drawers` 내 영역별 드로잉 함수, `widget_creator.create_widgets`

위 함수들을 우선 리팩터 목록에 포함하여, 각 책임 범위를 명확히 나누는 것을 목표로 한다.
