# 작업 계획서: `morph_face_by_polygons` 기능 분리

## 1. 배경
- `utils/face_morphing/polygon_morphing/core.py` 의 `morph_face_by_polygons` 함수가 입력 검증부터 픽셀 변환까지 모든 단계를 포함하고 있어 300+ 라인에 달함.
- 호출 측에서 "랜드마크만 준비" 또는 "이미지 페인트만 수행"처럼 부분 기능을 활용하기 어렵고, 고급 모드에서 중복 호출이 발생하여 디버깅이 힘듦.
- 단계별 책임을 나누면 기능 토글(예: 눈동자 준비 스킵, 선택 영역 모핑만)이나 성능 최적화 포인트를 독립적으로 관리할 수 있음.

## 2. 목표
1. `morph_face_by_polygons` 를 오케스트레이션 전용으로 단순화하고 하위 단계별 헬퍼를 도입한다.
2. 입력 검증/iris 준비/바운딩 박스 스케일링/픽셀 변환/출력 조합을 각각 독립적인 함수로 나눈다.
3. 각 단계가 dataclass 컨텍스트를 주고받도록 하여 부분 단계 호출과 기능 패스를 가능하게 한다.
4. 리팩터 진행 후에도 기존 유닛 테스트(`test_face_morphing_core.py`)와 주석이 유지되도록 한다.

## 3. 단계별 작업

### 단계 1: 컨텍스트/데이터 구조 설계
- [x] `IrisTransformContext`, `DelaunayContext`, `MorphRenderContext` 등 dataclass 정의.
- [x] 기존 `_prepare_iris_centers` 반환값을 `IrisTransformContext` 에 담도록 조정.

-### 단계 2: 준비 단계 분리
- [x] `_prepare_delaunay_inputs(iris_ctx, cached_bbox, image)` 함수 구현
  - 바운딩 박스 계산, 다운샘플링/스케일링, Delaunay 생성, working 이미지 생성까지 담당.
- [x] `_build_pixel_coordinate_map(delaunay_ctx)` 구현
  - bbox 내 좌표 그리드, simplex 인덱스 계산, valid simplex 추출.

### 단계 3: 렌더 단계 분리
- [x] `_apply_forward_transforms(delaunay_ctx, pixel_map, blend_ratio)`
  - 삼각형 검증/정변환 행렬 계산/픽셀 누적 로직을 캡슐화.
- [x] `_compose_result_image(delaunay_ctx, render_ctx)`
  - working 이미지 → 최종 PIL 이미지 변환 및 bbox 역스케일 복원.

### 단계 4: 오케스트레이터 정리
- [x] `morph_face_by_polygons` 에서 위 단계들을 순서대로 호출하도록 단순화.
- [x] 각 단계에서 예외 발생 시 세부 로그를 남기고 상위에서 graceful fallback.

### 단계 5: 선택 기능 패스 지원
- [ ] 매개변수로 `skip_pixel_warp=False` 등을 받아 렌더 단계를 생략할 수 있게 옵션 추가.
- [ ] (추가 논의) 눈동자만 이동하는 경우 `_prepare_iris_centers` 결과만 재활용하도록 API 설계.

## 4. 테스트 및 검증
- [ ] `test_face_morphing_core.py` 기존 케이스가 모두 통과하는지 확인.
- [ ] 슬라이더/드래그/고급 모드 시나리오에서 _prepare 호출 횟수와 morph 호출 횟수를 점검하는 로그 확인.
- [ ] 선택적 기능 패스를 사용할 때 (예: skip_pixel_warp) 시각적/수치적 diff 가 의도대로 유지되는지 확인.

## 5. 추가 고려 사항
- 리팩터 후 `_prepare_iris_centers` 나 `_check_and_fix_flipped_triangles` 같은 기존 헬퍼명은 그대로 두되, 새 헬퍼를 도입할 때 module-level private 함수로 두어 외부 API 표면을 유지.
- 향후 GPU 최적화 또는 streaming 처리를 단계 C/D 에서만 손대면 되도록 인터페이스를 설계.
