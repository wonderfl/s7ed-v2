# 작업 계획서: 얼굴 편집 화면 갱신 구조 개편

## 1. 배경
- 고급 모드 슬라이더/옵션/드래그 이벤트가 서로 다른 경로에서 중복으로 화면을 갱신하며, 상태가 꼬이고 유지보수가 어려움.
- 폴리곤(랜드마크)와 실제 편집 이미지 갱신이 분리되어 UX/디버깅 문제 발생.

## 2. 목표
1. `update_face_edit_display(...)` 단일 진입점을 통해 이미지/랜드마크/오버레이 갱신을 관리한다.
2. 이벤트 소스 플래그(슬라이더/옵션/드래그)를 도입하여 `_perform_morphing_update` 분기를 단순화한다.
3. 고급 모드에서도 슬라이더 변경 시 이미지 재계산( morph_face_by_polygons )이 확실히 수행되도록 한다.
4. 디스플레이 로직을 `PreviewManagerMixin`으로 집중시켜 이벤트별로 필요한 최소 갱신 플래그(image/landmarks/overlays)를 조합하여 호출 경로를 일원화한다.

## 3. 작업 순서 및 체크리스트

### 단계 1: 기존 갱신 흐름 분석
- [x] `show_edited_preview`, `update_face_features_display`, `_draw_landmark_polygons`, `apply_polygon_drag_final`가 각각 언제 호출되는지 호출 그래프 작성
- [x] 고급 모드/일반 모드별 `_perform_morphing_update` 실행 경로 정리
- [x] 분석 결과를 본 문서 하단 “분석 메모” 절에 기록하여 공유 경로 명시

### 단계 2: 이벤트 소스 플래그 설계
- [x] `self._last_change_source` 등 상태 변수를 정의하고 기본값 초기화
- [x] 슬라이더/옵션/드래그 이벤트 핸들러에서 플래그 세팅 추가
- [x] `_perform_morphing_update`에서 플래그 기반으로 `force_slider_mode` 및 후속 경로를 결정하도록 수정

#### 이벤트 소스 플래그 상세 설계
- `ChangeSource` 상수 집합(예: `('slider', 'option', 'drag', 'programmatic')`)을 `PreviewManagerMixin` 혹은 공용 믹스인에 정의하고, `self._last_change_source` 기본값을 `'unknown'`으로 초기화한다.
- **설정 지점**
  1. **슬라이더 이벤트**: `SliderUIMixin`의 `_create_*_slider` 헬퍼에서 `on_slider_release`/`reset_slider` 직전에 `self._set_change_source('slider')` 호출. 공통 헬퍼를 만들기 어려우면 `on_morphing_change` 호출 직전에 래핑 함수(`_trigger_slider_change`) 사용.
  2. **옵션/체크박스 이벤트**: `HandlersMixin` 내 `on_*_change` 계열에서 편집 적용 전에 `self._set_change_source('option')` 호출. 예) `on_individual_region_change`, `on_landmarks_display_change`, `on_eye_region_display_change` 등.
  3. **드래그 이벤트**: `PolygonDragHandlerMixin`에서 `on_polygon_drag_start/drag/end` 및 `apply_polygon_drag_final`을 호출하는 경로에 `self._set_change_source('drag')`를 삽입. 드래그 중 중복 호출을 피하기 위해 guard flag와 함께 마지막 값 유지.
  4. **프로그램/초기화 갱신**: 파일 열기, 자동 정렬 등 내부적으로 상태를 재설정하는 함수에서는 `self._set_change_source('programmatic')` 사용.
- **사용 지점**
  - `_perform_morphing_update`에서 `source = getattr(self, '_last_change_source', 'unknown')`를 읽고 분기 처리:
    * `slider`/`drag`: `force_slider_mode=True`로 `apply_polygon_drag_final` 호출, 이어서 `update_face_edit_display(image=True, landmarks=True)` 실행.
    * `option`: `force_slider_mode=False`, 필요 시 `update_face_edit_display(landmarks=True, overlays=True)`만 호출해 이미지 재계산을 건너뜀.
    * `programmatic`/`unknown`: 기존 시그니처 비교 로직 유지하되 안전하게 전체 갱신.
  - `update_face_edit_display` 완성 후에는 `_perform_morphing_update`가 직접 미리보기 함수를 호출하지 않고, 소스에 맞는 플래그 셋만 전달.
- **리셋 규칙**
  - 갱신 완료(`update_face_edit_display` 호출 끝) 시 `_last_change_source = 'none'`으로 초기화하여 다음 이벤트가 명확히 기록되도록 한다.
  - 드래그 중에는 `self._drag_in_progress`를 활용해 slider/option 이벤트와 충돌하지 않도록 guard.

### 단계 3: `update_face_edit_display` 구현
- [ ] 함수 시그니처(예: `update_face_edit_display(image=False, landmarks=False, overlays=False)`) 정의
- [ ] 내부에서 필요한 기존 함수 호출 정리(`show_edited_preview`, `update_face_features_display`, 영역 오버레이 등)
- [ ] 모든 이벤트가 이 함수를 통해서만 화면을 갱신하도록 기존 직접 호출을 정리
- [ ] `PreviewManagerMixin`( `gui/face_edit/preview.py` ) 내에서 디스플레이 전용 책임으로 구현하고, 이미지/랜드마크/오버레이 각각의 최소 갱신 플래그를 인자로 받아 조건부로 실행되도록 설계
- [ ] 이벤트 소스 플래그와 연계하여 슬라이더/옵션/드래그별 필요한 갱신 범위를 명시하고, `_perform_morphing_update`에서는 이 함수를 호출만 하도록 단순화

### 단계 4: 고급 모드 이미지 재계산 보장
- [ ] 슬라이더 이벤트 시 `apply_polygon_drag_final(force_slider_mode=True)` 이후에도 이미지 갱신 경로가 실행되도록 리팩터링
- [ ] 옵션 변경 시에는 `force_slider_mode=False` + 부분 갱신만 수행하도록 분기
- [ ] 중복 폴리곤 렌더 제거(필요 시 `_apply_common_sliders_to_landmarks` 내 렌더 호출 조건부 처리)

### 단계 5: 테스트 및 검증
- [ ] 일반 모드 슬라이더/옵션/드래그 각각 수행하여 이미지·폴리곤이 동시에 갱신되는지 확인
- [ ] 고급 모드에서 Size X/Y, 위치, 중심 오프셋 슬라이더 조작 시 이미지까지 반영되는지 확인
- [ ] 옵션 토글(홍채 맵핑 등) 시 위치 유지 + 화면 갱신만 수행되는지 확인
- [ ] 로그(guide axis, morph_face_by_polygons) 중복 호출 여부 재확인

## 4. 참고 사항
- 리팩터링 과정에서 기존 디버그 로그를 유지하되, 새로운 단일 갱신 함수 내에서 최소한의 로그만 남겨 가독성을 확보한다.
- 변경 범위가 크므로 단계별 커밋/테스트를 권장한다.

## 부록: 분석 메모
- [x] (단계 1) preview.py `show_original_preview`/`show_edited_preview`가 이미지·랜드마크·가이드라인을 중첩 호출하며 캔버스 재렌더가 중복되는 시나리오 요약
  - `show_original_preview`는 캔버스 이미지 교체 후 eye/lip 영역, bbox, landmark, guide line 업데이트까지 직접 호출. 확대/이동/옵션 토글 등 다양한 이벤트마다 전체 함수를 다시 불러 중복 렌더 발생.
  - `show_edited_preview` 역시 이미지 재배치 + bbox + landmark + guide line을 모두 처리하여, 동일 이벤트에서 원본/편집 캔버스가 각자 별도의 렌더 사이클을 돌고 있음.
  - 결과적으로 슬라이더/옵션/드래그가 각각 `apply_editing` → `show_edited_preview` → `update_face_features_display`를 반복 호출하며, 랜드마크와 가이드 라인이 두 번 이상 재그려지는 케이스가 다수 확인됨.
- [x] (단계 1) `_perform_morphing_update`의 고급/일반 모드 분기에서 `apply_polygon_drag_final`, `apply_editing`, `_draw_landmark_polygons`, `update_face_features_display` 호출 순서를 다이어그램으로 정리
  - **일반 모드**: `on_morphing_change` → `_perform_morphing_update` → (옵션에 따라) `update_polygons_only` → `apply_editing` → 내부에서 `show_edited_preview` 호출 → 이후 랜드마크/폴리곤 갱신이 다시 트리거.
  - **고급 모드**: `_perform_morphing_update`에서 즉시 `apply_polygon_drag_final(force_slider_mode=True)` 실행 후 `return`, 따라서 이후 `apply_editing` 경로가 생략되고 슬라이더 변경 시 이미지 재계산이 누락되는 문제가 발생.
  - 두 경로 모두에서 `update_face_features_display`, `_draw_landmark_polygons`가 직접 호출되거나 `apply_editing`/`apply_polygon_drag_final` 내부에서 다시 호출되어, 동일 이벤트당 최대 3회 이상 중복 실행되는 흐름을 확인.
