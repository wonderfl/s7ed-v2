# Eye Drag Mapping 구조 재설계 명세

## 문제 분석

### 현재 구조의 문제점
1. **설계 오류**: `iris_mapping_method`로 인덱스를 계산하지만 실제 변형에는 사용하지 않음
2. **분리된 로직**: 인덱스 계산과 변형 적용이 완전히 분리되어 있음
3. **불필요한 계산**: 8개 vs 32개 포인트를 계산하지만 결과적으로 버려짐
4. **의미 없는 옵션**: 두 옵션이 사실상 동일한 기능을 함

### 근본 원인
- `selected_point_indices = None` 전달 → 선택적 변형 로직 무시
- `iris_mapping_indices` 계산 후 실제 변형에는 사용되지 않음
- 항상 전체 468개 랜드마크로 전체 변형 적용

## 재설계 목표

1. **옵션별 실제 차이 구현**: 8개 vs 32개 포인트가 실제로 다른 변형 결과를 만들어냄
2. **구조적 일관성**: 인덱스 계산부터 변형 적용까지 일관된 흐름
3. **효율성**: 불필요한 계산 제거
4. **확장성**: 새로운 맵핑 옵션 추가 용이

## 새로운 구조 설계

### 1. 데이터 흐름 재설계
```
옵션 선택 (iris_mapping_method)
↓
인덱스 계산 (calculate_mapping_indices)
↓
선택적 변형 적용 (apply_selective_morphing)
↓
이미지 결과 출력
```

### 2. 핵심 함수 재설계

#### 2.1 `calculate_mapping_indices()`
```python
def calculate_mapping_indices(iris_mapping_method, landmark_structure="468"):
    """
    맵핑 방법에 따른 변형 인덱스 계산
    
    Args:
        iris_mapping_method: "iris_outline" 또는 "eye_landmarks"
        landmark_structure: "468" 또는 "478"
    
    Returns:
        list: 변형에 사용할 인덱스 리스트
    """
    if iris_mapping_method == "iris_outline":
        if landmark_structure == "468":
            return [33, 133, 145, 246, 362, 398, 384, 263]  # 8개
        else:
            return [474, 475, 476, 477, 469, 470, 471, 472]  # 8개
    else:  # eye_landmarks
        if landmark_structure == "468":
            return [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246,
                   362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398]  # 32개
        else:
            # 478개 구조용 인덱스
            return [...]
```

#### 2.2 `apply_selective_morphing()`
```python
def apply_selective_morphing(image, original_landmarks, transformed_landmarks, 
                           mapping_indices, iris_centers):
    """
    선택적 인덱스를 사용한 변형 적용
    
    Args:
        image: 원본 이미지
        original_landmarks: 원본 랜드마크
        transformed_landmarks: 변형된 랜드마크
        mapping_indices: 변형에 사용할 인덱스
        iris_centers: 눈동자 중심점 좌표
    
    Returns:
        PIL.Image: 변형된 이미지
    """
    # 1. Delaunay 삼각형 생성
    tri = create_delaunay_triangulation(original_landmarks)
    
    # 2. mapping_indices를 포함하는 삼각형 필터링
    selected_triangles = filter_triangles_by_indices(tri, mapping_indices)
    
    # 3. 선택된 삼각형만 변형 적용
    result = apply_triangular_morphing(image, tri, selected_triangles, 
                                     original_landmarks, transformed_landmarks)
    
    return result
```

### 3. 호출 구조 재설계

#### 3.1 `polygon_drag_handler.py` 수정
```python
def apply_polygon_drag_final(self, force_slider_mode=True):
    # 맵핑 방법 가져오기
    iris_mapping_method = getattr(self, 'iris_mapping_method', None)
    iris_mapping_method_val = iris_mapping_method.get() if iris_mapping_method else "iris_outline"
    
    # 인덱스 계산
    mapping_indices = calculate_mapping_indices(iris_mapping_method_val, "468")
    
    # 변형 적용
    result = face_morphing.morph_face_by_polygons(
        self.current_image,
        original_landmarks_for_morph,
        custom_landmarks_for_morph,
        mapping_indices=mapping_indices,  # 새로운 파라미터
        iris_centers=(left_center, right_center)
    )
```

#### 3.2 `core.py` 수정
```python
def morph_face_by_polygons(image, original_landmarks, transformed_landmarks,
                          mapping_indices=None, iris_centers=None):
    """
    새로운 구조의 모핑 함수
    
    Args:
        image: 원본 이미지
        original_landmarks: 원본 랜드마크
        transformed_landmarks: 변형된 랜드마크
        mapping_indices: 변형에 사용할 인덱스 (None이면 전체 변형)
        iris_centers: 눈동자 중심점 좌표
    
    Returns:
        PIL.Image: 변형된 이미지
    """
    if mapping_indices is None:
        # 전체 변형 (기존 방식)
        return apply_full_morphing(image, original_landmarks, transformed_landmarks, iris_centers)
    else:
        # 선택적 변형 (새로운 방식)
        return apply_selective_morphing(image, original_landmarks, transformed_landmarks, 
                                      mapping_indices, iris_centers)
```

## 구현 단계

### Phase 1: 기본 구조 구현
1. `calculate_mapping_indices()` 함수 구현
2. `apply_selective_morphing()` 함수 구현
3. `morph_face_by_polygons()` 시그니처 변경

### Phase 2: 통합 및 테스트
1. `polygon_drag_handler.py` 수정
2. 두 옵션 간 차이 검증
3. 성능 테스트 및 최적화

### Phase 3: 확장 및 정리
1. 불필요한 코드 제거
2. 새로운 맵핑 옵션 추가 용이성 확보
3. 문서화 및 테스트 케이스 작성

## 예상 결과

### "눈동자 외곽선 맵핑" 선택 시
- 8개 핵심 인덱스만 사용
- 눈동자 주변 좁은 영역만 정밀하게 변형
- 자연스러운 눈동자 움직임 효과

### "눈 랜드마크 맵핑" 선택 시
- 32개 눈 관련 인덱스 사용
- 눈 전체 영역(눈꺼풀, 눈꼬리 등) 포함하여 변형
- 더 넓은 범위의 자연스러운 변형 효과

## 기술적 고려사항

1. **성능**: 선택적 변형이 전체 변형보다 빨라야 함
2. **품질**: 두 옵션 간 시각적 차이가 명확해야 함
3. **안정성**: 기존 기능과의 호환성 유지
4. **확장성**: 새로운 맵핑 옵션 추가가 용이해야 함

## 롤백 계획

문제 발생 시 기존 구조로 복원:
1. `polygon_drag_handler.py`에서 `selected_indices = None` 복원
2. `core.py`에서 기존 `morph_face_by_polygons` 함수 복원
3. `iris_mapping_method` 파라미터 무시하도록 설정

## 검증 방법

1. **기능 검증**: 두 옵션 선택 시 다른 변형 결과 확인
2. **성능 검증**: 선택적 변형의 속도 측정
3. **시각적 검증**: 사용자 관점에서 자연스러움 평가
4. **회귀 검증**: 기존 기능에 영향 없는지 확인

## 체크리스트

### Phase 1: 기본 구조 구현
- [ ] `calculate_mapping_indices()` 함수 구현 완료
- [ ] `apply_selective_morphing()` 함수 구현 완료  
- [ ] `morph_face_by_polygons()` 시그니처 변경 완료
- [ ] 기존 함수와의 호환성 확인
- [ ] 단위 테스트 작성

### Phase 2: 통합 및 테스트
- [ ] `polygon_drag_handler.py` 수정 완료
- [ ] "눈동자 외곽선 맵핑" 옵션 동작 확인
- [ ] "눈 랜드마크 맵핑" 옵션 동작 확인
- [ ] 두 옵션 간 시각적 차이 확인
- [ ] 성능 벤치마크 테스트 완료
- [ ] 메모리 사용량 확인

### Phase 3: 확장 및 정리
- [ ] 불필요한 코드 제거 완료
- [ ] 새로운 맵핑 옵션 추가 구조 확인
- [ ] API 문서화 완료
- [ ] 사용자 매뉴얼 업데이트
- [ ] 최종 통합 테스트 완료

### 품질 검증
- [ ] **시각적 차이**: 8개 vs 32개 포인트 변형 결과 구별 가능
- [ ] **성능**: 선택적 변형이 전체 변형보다 20% 이상 빠름
- [ ] **안정성**: 100회 반복 테스트 시 오류 없음
- [ ] **호환성**: 기존 슬라이더 기능 정상 작동
- [ ] **확장성**: 새로운 맵핑 옵션 추가 시 30분 내 구현 가능

### 사용자 시나리오 테스트
- [ ] 눈동자 드래그 시 즉시 변형 적용
- [ ] 옵션 변경 시 즉시 다른 결과 표시
- [ ] 여러 번 옵션 전환 시 안정성 유지
- [ ] 큰 이미지에서도 성능 저하 없음
- [ ] 다른 얼굴 부위 편집 시 영향 없음

### 최종 릴리즈 확인
- [ ] 모든 에러 핸들링 완료
- [ ] 로그 메시지 적절히 표시
- [ ] 사용자 인터페이스 일관성 유지
- [ ] 코드 리뷰 완료
- [ ] 배포용 빌드 테스트 완료
