# 랜드마크 관리 구조 근본 문제 분석 및 개선 계획

**작성 일시**: 2026-01-19 14:08  
**작업 목적**: 랜드마크 관리 구조의 근본적인 문제점 파악 및 개선 방안 수립  
**코드 레벨 완료 일시**: 2026-01-19  
**하위 호환성 코드 제거 완료 일시**: 2026-01-19  
**최종 상태**: 코드 레벨 완료, 사용자 테스트 대기

## 현재 문제점 분석

### 1. 이중 관리 문제

**문제**: LandmarkManager가 있지만 여전히 `self.custom_landmarks`도 직접 관리하고 있음

**현황**:
- `LandmarkManager._custom_landmarks`: 중앙 관리
- `self.custom_landmarks`: 하위 호환성을 위해 유지
- 두 곳을 동기화하는 코드가 38곳에 산재

**영향**:
- 동기화 실패 시 데이터 불일치
- 어느 쪽이 진실의 원천인지 불명확
- 버그 발생 시 추적 어려움

### 2. 직접 수정 문제

**문제**: 8개 파일에서 38곳에서 `self.custom_landmarks`를 직접 수정

**수정 위치**:
1. `morphing/logic.py`: 4곳
2. `polygon_drag_handler.py`: 5곳
3. `__init__.py`: 5곳
4. `morphing/editing_steps.py`: 2곳
5. `file.py`: 1곳
6. `polygon_renderer/drawing.py`: 4곳
7. `morphing/utils.py`: 1곳
8. `landmark_manager.py`: 내부 관리

**영향**:
- 규칙 없는 수정으로 인한 예측 불가능한 동작
- 드래그 변경이 덮어써지는 문제
- 상태 추적 불가능

### 3. 드래그 추적 문제

**문제**: 드래그로 변경된 포인트를 매번 계산하는 방식

**현재 방식**:
```python
# 원본과 custom_landmarks를 비교하여 차이가 0.5픽셀 이상인 포인트를 드래그로 간주
dragged_indices = set()
for idx in range(len(original_face_landmarks)):
    diff = ((custom_x - orig_x)**2 + (custom_y - orig_y)**2)**0.5
    if diff > 0.5:
        dragged_indices.add(idx)
```

**문제점**:
- 슬라이더 변형으로도 차이가 날 수 있어 오인 가능
- 매번 계산하므로 성능 저하
- 드래그 취소 시 추적 불가능

### 4. 상태 변경 규칙 부재

**문제**: 언제, 어떻게 `custom_landmarks`를 수정해야 하는지 명확한 규칙이 없음

**현재 상황**:
- 드래그 시작 시: `custom_landmarks` 초기화
- 드래그 중: `custom_landmarks[idx]` 직접 수정
- 드래그 종료: `_apply_common_sliders_to_landmarks` 호출 → 덮어쓰기 가능
- 사이즈 변경: `transformed_landmarks`로 덮어쓰기
- 슬라이더 변경: `_apply_common_sliders_to_landmarks`에서 덮어쓰기
- 리셋: 원본으로 복원

**영향**:
- 각 동작이 서로 간섭
- 예측 불가능한 동작
- 버그 발생 시 원인 파악 어려움

### 5. 데이터 흐름 불명확

**문제**: 랜드마크 데이터가 어떻게 변환되는지 추적 불가능

**현재 흐름**:
```
original_landmarks (478개)
  ↓
original_face_landmarks (468개) + original_iris_landmarks (10개)
  ↓
face_landmarks (468개) - 초기 편집
  ↓
transformed_landmarks (468개) - 사이즈 변경
  ↓
custom_landmarks (468개 또는 470개) - 최종 사용자 수정
  ↓
morph_face_by_polygons (470개 필요)
```

**문제점**:
- 각 단계에서 덮어쓰기 발생
- 이전 단계 정보 손실
- 드래그 변경 추적 불가능

## 개선 방안

### 1. 완전한 중앙화 + 직접 참조 (복사본 제거)

**목표**: 복사본을 만들지 않고 직접 참조만 사용

**핵심 아이디어**:
- `self.custom_landmarks`를 property로 만들어서 `landmark_manager._custom_landmarks`를 직접 참조
- 복사본은 필요할 때만 (예: morph_face_by_polygons에 전달할 때)
- 수정은 LandmarkManager 메서드를 통해서만

**방법**:
1. `self.custom_landmarks`를 property로 변경 → 직접 참조 (복사본 없음)
2. 읽기는 직접 참조로 빠르게
3. 수정은 `landmark_manager.set_custom_landmarks()` 또는 전용 메서드만 사용
4. `get_custom_landmarks()`는 필요할 때만 복사본 반환 (기본은 직접 참조)

**예시**:
```python
# __init__.py에 추가
@property
def custom_landmarks(self):
    """하위 호환성: LandmarkManager의 _custom_landmarks 직접 참조 (복사본 없음)"""
    if hasattr(self, 'landmark_manager'):
        return self.landmark_manager._custom_landmarks  # 직접 참조
    return getattr(self, '_custom_landmarks', None)

@custom_landmarks.setter
def custom_landmarks(self, value):
    """하위 호환성: LandmarkManager를 통해서만 수정"""
    if hasattr(self, 'landmark_manager'):
        self.landmark_manager.set_custom_landmarks(value, reason="legacy_setter")
    else:
        # LandmarkManager가 없으면 직접 저장 (하위 호환성)
        self._custom_landmarks = value

# LandmarkManager 수정
def get_custom_landmarks(self, copy=False) -> Optional[List[Tuple[float, float]]]:
    """사용자 수정 랜드마크 반환
    
    Args:
        copy: True면 복사본 반환, False면 직접 참조 (기본값: False)
    """
    if self._custom_landmarks is not None:
        return list(self._custom_landmarks) if copy else self._custom_landmarks
    return None
```

**성능 향상**:
- 복사본 생성 제거 → 메모리 사용량 감소
- 동기화 불필요 → 수정 속도 향상
- 직접 참조 → 읽기 속도 향상

### 2. 드래그 추적 명시화

**목표**: 드래그로 변경된 포인트를 명시적으로 추적

**방법**:
1. `LandmarkManager`에 `_dragged_indices: Set[int]` 필드 추가
2. 드래그 시작 시: `mark_as_dragged(index)` 호출
3. 드래그 종료 시: `unmark_as_dragged(index)` 호출 (취소 시)
4. 슬라이더 변형 시: `dragged_indices`에 있는 포인트는 건너뛰기

**예시**:
```python
class LandmarkManager:
    def __init__(self):
        # ...
        self._dragged_indices: Set[int] = set()  # 드래그로 변경된 포인트 인덱스
    
    def mark_as_dragged(self, index: int):
        """드래그로 변경된 포인트로 표시"""
        self._dragged_indices.add(index)
    
    def unmark_as_dragged(self, index: int):
        """드래그 표시 제거 (취소 시)"""
        self._dragged_indices.discard(index)
    
    def get_dragged_indices(self) -> Set[int]:
        """드래그로 변경된 포인트 인덱스 반환"""
        return set(self._dragged_indices)  # 복사본 반환
    
    def clear_dragged_indices(self):
        """드래그 표시 초기화"""
        self._dragged_indices.clear()
```

### 3. 상태 변경 규칙 명확화

**목표**: 언제, 어떻게 랜드마크를 수정해야 하는지 명확한 규칙 수립

**규칙**:
1. **드래그 시작**: `custom_landmarks`가 없으면 현재 상태로 초기화
2. **드래그 중**: `update_custom_landmark(index, position)` 사용, `mark_as_dragged(index)` 호출
3. **드래그 종료**: `mark_as_dragged(index)` 유지, 슬라이더 변형 적용 시 제외
4. **사이즈 변경**: 드래그된 포인트도 함께 변환 (비율 유지)
5. **슬라이더 변경**: 드래그된 포인트는 제외하고 변환
6. **리셋**: 모든 드래그 표시 제거, 원본으로 복원

**예시**:
```python
def on_polygon_drag(self, event, landmark_index, canvas_obj):
    # ...
    if hasattr(self, 'landmark_manager'):
        self.landmark_manager.update_custom_landmark(landmark_index, (img_x, img_y))
        self.landmark_manager.mark_as_dragged(landmark_index)
    # ...
```

### 4. 데이터 흐름 명확화

**목표**: 랜드마크 데이터 변환 과정을 명확히 추적 가능하게

**방법**:
1. 각 변환 단계를 별도 메서드로 분리
2. 변환 이력 추적 (선택사항)
3. 디버깅용 로그 강화

**예시**:
```python
def apply_slider_transform(self, transform_func, exclude_dragged=True):
    """슬라이더 변형 적용
    
    Args:
        transform_func: 변형 함수
        exclude_dragged: 드래그된 포인트 제외 여부
    """
    base = self.get_custom_landmarks() or self.get_original_face_landmarks()
    dragged = self.get_dragged_indices() if exclude_dragged else set()
    
    result = []
    for idx, point in enumerate(base):
        if idx in dragged:
            result.append(point)  # 드래그된 포인트는 그대로 유지
        else:
            result.append(transform_func(point, idx))
    
    self.set_custom_landmarks(result, reason="slider_transform")
```

## 작업 계획

### 1단계: LandmarkManager 확장
- [x] `_dragged_indices` 필드 추가
- [x] `mark_as_dragged()`, `unmark_as_dragged()`, `get_dragged_indices()`, `clear_dragged_indices()`, `is_dragged()` 메서드 추가
- [x] `update_custom_landmark(index, position)` 메서드 추가 (드래그용, 자동으로 mark_as_dragged 호출)
- [ ] `apply_slider_transform()` 메서드 추가 (슬라이더 변형용) - 선택사항, 현재는 직접 구현

### 2단계: 하위 호환성 속성 변경
- [x] `self.custom_landmarks`를 property로 변경 (직접 참조, setter는 LandmarkManager 경유)
- [x] `self.original_landmarks`를 property로 변경
- [x] `self.face_landmarks`를 property로 변경
- [x] `self.transformed_landmarks`를 property로 변경
- [x] 모든 직접 인덱스 접근 코드를 LandmarkManager 메서드 호출로 변경 (완료)
  - 주요 코드: LandmarkManager 메서드 사용
  - 하위 호환성 코드: 주석 추가 및 안전성 검사 추가 (LandmarkManager가 없을 때만 실행)

### 3단계: 드래그 추적 적용
- [x] `on_polygon_drag`: `update_custom_landmark()` 사용 (자동으로 mark_as_dragged 호출)
- [x] `_apply_common_sliders_to_landmarks`: `get_dragged_indices()` 사용하여 제외
- [x] `on_polygon_drag_start`: 드래그 시작 시 초기화 및 로그 추가 (완료)
  - custom_landmarks가 없으면 현재 상태로 초기화
  - 드래그 시작 로그 추가
- [x] `on_polygon_drag_end`: 드래그 종료 처리 및 로그 추가 (완료)
  - 드래그 종료 로그 추가 (드래그된 포인트 개수 포함)
  - 드래그 표시는 유지 (슬라이더 변형 시 제외하기 위해)

### 4단계: 사이즈 변경 로직 수정
- [x] `apply_editing`: 드래그된 포인트도 함께 변환하되, 드래그 표시 유지 (완료)
  - `custom_landmarks`를 기준으로 변환하도록 수정
  - 불필요한 복사본 생성 제거 (함수 내부에서만 복사본 생성)
  - 드래그 표시는 유지 (변환은 했지만 드래그로 변경된 것으로 표시 유지)
- [x] `transform_points_for_eye_size`: 드래그된 포인트도 변환 (함수 자체는 수정 불필요, 호출 방식 개선)
- [x] `_update_landmarks_after_editing`: 사이즈 변경 시 드래그된 포인트 보존 로직 추가 (2026-01-19)
  - 이전 `transformed_landmarks`를 기준으로 드래그 오프셋 계산
  - 데이터 플로우 문제 해결 (이전 사이즈 변환 + 드래그 상태 고려)
  - 디버깅 로그 추가
- [x] `update_polygons_only`: 폴리곤 업데이트 시에도 드래그된 포인트 보존 로직 추가 (2026-01-19)
  - `_update_landmarks_after_editing`과 동일한 로직 적용
  - 눈 크기 슬라이더 변경 시에도 드래그된 포인트 보존

### 6단계: Property 복사본 생성 문제 수정 (확인 완료)

**상태**: 실제 확인 결과 이미 해결됨 ✅

**확인 결과**:
1. **`get_original_landmarks_full()`**: 직접 참조 반환 ✅ (landmark_manager.py:388줄)
2. **`get_face_landmarks()`**: 직접 참조 반환 ✅ (landmark_manager.py:155줄)
3. **`get_transformed_landmarks()`**: 직접 참조 반환 ✅ (landmark_manager.py:174줄)
4. **Property getter들**: 모두 직접 참조 반환 ✅ (__init__.py:291-362줄)
5. **`set_custom_landmarks()`**: 직접 참조로 저장 ✅ (landmark_manager.py:189줄)

**결론**: 6단계는 이미 완료되어 있음. 계획서 작성 시 예상했던 문제가 실제로는 발생하지 않았음.

### 5단계: 테스트 및 검증
- [x] 코드 레벨 완료 (린터 오류 없음)
- [ ] 드래그 추적 테스트 (사용자 테스트 필요)
- [ ] 슬라이더 변형 시 드래그 포인트 보존 테스트 (사용자 테스트 필요)
- [ ] 사이즈 변경 시 드래그 포인트 변환 테스트 (사용자 테스트 필요)
- [ ] 리셋 시 드래그 표시 제거 테스트 (사용자 테스트 필요)

### 7단계: 하위 호환성 코드 제거 ✅
**목적**: LandmarkManager가 항상 초기화되므로 불필요한 하위 호환성 코드 제거

**확인 사항**:
- `__init__.py` 70줄: `self.landmark_manager = LandmarkManager()` 항상 초기화됨
- `hasattr(self, 'landmark_manager')` 체크: 73곳 (모두 불필요)

**작업 내용**:
- [x] 모든 `hasattr(self, 'landmark_manager')` 체크 제거 (완료)
- [x] `else` 블록의 하위 호환성 코드 제거 (`_custom_landmarks_legacy` 등) (완료)
- [x] Property의 `hasattr` 체크 제거 (직접 `landmark_manager` 사용) (완료)
- [x] 레거시 변수 제거 (`_custom_landmarks_legacy`, `_original_landmarks_legacy` 등) (완료)
- [x] 코드 단순화 및 명확화 (완료)
- [x] 초기화 순서 수정 (`landmark_manager`를 property 설정 전에 초기화) (완료)

**작업 완료**:
- 총 73곳의 `hasattr` 체크 제거
- 모든 하위 호환성 `else` 블록 제거
- Property에서 직접 `landmark_manager` 사용하도록 변경
- 레거시 변수 초기화 코드 제거
- 초기화 순서 문제 해결 (AttributeError 수정)

**수정된 파일**:
- `gui/face_edit/__init__.py` - Property 단순화 및 초기화 순서 수정
- `gui/face_edit/polygon_drag_handler.py` - 모든 hasattr 체크 제거
- `gui/face_edit/morphing/logic.py` - 모든 hasattr 체크 제거
- `gui/face_edit/morphing/editing_steps.py` - 모든 hasattr 체크 제거, 사이즈 변경 시 드래그된 포인트 보존 로직 추가
- `gui/face_edit/polygon_renderer/drawing.py` - 모든 hasattr 체크 제거
- `gui/face_edit/morphing/utils.py` - 모든 hasattr 체크 제거, 폴리곤 업데이트 시 드래그된 포인트 보존 로직 추가
- `gui/face_edit/file.py` - 모든 hasattr 체크 제거
- `gui/face_edit/polygon_renderer/all_tab_drawer.py` - 모든 hasattr 체크 제거
- `gui/face_edit/polygon_renderer/tab_drawers.py` - 모든 hasattr 체크 제거
- `gui/face_edit/morphing/handlers.py` - 모든 hasattr 체크 제거
- `gui/face_edit/landmark_display.py` - 모든 hasattr 체크 제거

**결과**:
- 코드 단순화 (73곳의 불필요한 체크 제거)
- `custom_landmarks` 사용 명확화
- 유지보수성 향상
- 프로그램 정상 실행 확인

## 예상 효과

1. **버그 감소**: 명확한 규칙으로 예측 불가능한 동작 제거
2. **유지보수성 향상**: 중앙화된 관리로 수정 위치 명확
3. **성능 향상**: 매번 계산하지 않고 명시적 추적
4. **디버깅 용이**: 드래그 상태를 명확히 추적 가능

## 추가 고려사항

### 1. 직접 인덱스 접근 문제

**문제**: property로 직접 참조를 반환하면 여전히 `custom[idx] = ...` 같은 직접 수정이 가능

**발견된 위치**:
- `polygon_drag_handler.py`: `custom[landmark_index] = (img_x, img_y)` (204줄)
- `polygon_drag_handler.py`: `custom[left_idx] = ...`, `custom[right_idx] = ...` (383, 393줄)

**해결 방안**:
1. **즉시 수정**: 모든 직접 인덱스 접근을 `update_custom_landmark()` 메서드로 변경
2. **읽기 전용 래퍼**: property가 읽기 전용 리스트를 반환 (수정 시 에러 발생)
3. **명시적 메서드 사용**: `custom[idx] = ...` 대신 `landmark_manager.update_custom_landmark(idx, ...)` 사용

**권장**: 1번 방법 (즉시 수정) - 가장 명확하고 안전

### 2. 안전성 고려사항

**직접 참조의 위험성**:
- property가 직접 참조를 반환하면 외부에서 수정 가능
- 하지만 setter를 통해 LandmarkManager를 경유하도록 강제 가능

**해결책**:
```python
@property
def custom_landmarks(self):
    """직접 참조 반환 (읽기용)"""
    if hasattr(self, 'landmark_manager'):
        return self.landmark_manager._custom_landmarks
    return getattr(self, '_custom_landmarks', None)

@custom_landmarks.setter
def custom_landmarks(self, value):
    """수정은 LandmarkManager를 통해서만"""
    if hasattr(self, 'landmark_manager'):
        self.landmark_manager.set_custom_landmarks(value, reason="legacy_setter")
    else:
        self._custom_landmarks = value

# 직접 인덱스 접근은 막을 수 없으므로, 모든 코드를 메서드 호출로 변경
```

### 3. 마이그레이션 전략

**순서**:
1. **1단계**: LandmarkManager 확장 (기존 코드 영향 없음)
2. **2단계**: 직접 인덱스 접근 코드 수정 (4곳)
   - `polygon_drag_handler.py`: `custom[idx] = ...` → `update_custom_landmark(idx, ...)`
3. **3단계**: property 추가 (기존 코드 자동 호환)
4. **4단계**: 직접 할당 코드 점진적 변경 (38곳)
5. **5단계**: 테스트 및 검증

**중요**: 2단계(직접 인덱스 접근 수정)를 먼저 해야 property 적용 시 안전

### 4. 성능 측정

**측정 항목**:
- 복사본 생성 횟수 감소 (38곳 → 0곳)
- 메모리 사용량 감소 (중복 저장 제거)
- 동기화 오버헤드 제거

**측정 방법**:
- `_log_change()`에 성능 로그 추가 (선택사항)
- 프로파일링으로 복사본 생성 지점 확인

### 5. 롤백 계획

**문제 발생 시**:
1. property 제거하고 기존 방식으로 복원
2. `get_custom_landmarks()` 복사본 반환 방식으로 복원
3. 단계별 커밋으로 쉽게 롤백 가능

**안전장치**:
- 각 단계마다 별도 커밋
- 테스트 통과 후에만 다음 단계 진행

## 작업 완료 요약

### 완료된 단계
- ✅ 1단계: LandmarkManager 확장
- ✅ 2단계: 하위 호환성 속성 변경
- ✅ 3단계: 드래그 추적 적용
- ✅ 4단계: 사이즈 변경 로직 수정
- ✅ 5단계: 코드 레벨 테스트 및 검증
- ✅ 6단계: Property 복사본 생성 문제 확인
- ✅ 7단계: 하위 호환성 코드 제거

### 해결된 버그 (2026-01-19)
- ✅ **폴리곤 수정 후 사이즈 변경 시 드래그된 포인트 초기화 문제**
  - **문제**: 폴리곤을 드래그로 수정한 후 사이즈 슬라이더를 변경하면 드래그한 포인트가 원래 위치로 돌아가고 사이즈만 변경됨
  - **원인**: 
    1. 데이터 플로우 문제: `custom_landmarks`는 이전 사이즈 변환 + 드래그가 적용된 상태인데, 드래그 오프셋을 원본 기준으로 계산하여 이전 사이즈 변환이 중복 적용됨
    2. `update_polygons_only`에서 드래그된 포인트를 보존하지 않음
  - **해결**:
    1. `_update_landmarks_after_editing`: 이전 `transformed_landmarks`를 기준으로 드래그 오프셋 계산 (순수 드래그 오프셋만 추출)
    2. `update_polygons_only`: 동일한 로직 적용하여 폴리곤 업데이트 시에도 드래그된 포인트 보존
    3. 디버깅 로그 추가로 데이터 플로우 추적 가능
  - **결과**: 사이즈 변경 시에도 드래그된 포인트가 올바르게 보존됨

### 남은 작업
- ⏳ 사용자 테스트: 실제 사용 시나리오에서 동작 확인 필요
  - ✅ 폴리곤 수정 후 사이즈 변경 시 드래그된 포인트 보존 확인 (2026-01-19)
  - ✅ 폴리곤 수정 후 사이즈 변경 시 드래그된 포인트 보존 확인 (2026-01-19)

## 주의사항

1. ~~**하위 호환성 유지**: 기존 코드가 동작하도록 property 사용~~ ✅ 완료 (하위 호환성 코드 제거됨)
2. ✅ **점진적 전환**: 단계적으로 완료됨
3. ⏳ **테스트 강화**: 사용자 테스트 대기 중
4. ✅ **직접 인덱스 접근 우선 수정**: 완료됨
5. ✅ **안전한 롤백**: 각 단계별 커밋 완료
