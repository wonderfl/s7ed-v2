# 작업계획서: 뒤집힌 삼각형 사전 감지 및 시각화

## 작업 목표
폴리곤 수정 시 뒤집힌 삼각형 검사 반복을 제거하고, 폴리곤을 그릴 때 뒤집힌 삼각형을 미리 감지하여 시각적으로 표시합니다.

## 문제 분석
1. **현재 문제**: `morph_face_by_landmarks()`에서 뒤집힌 삼각형 검사를 최대 12회 반복하여 성능 저하
2. **사용자 요구**: 수동으로 폴리곤을 수정하는 경우, 뒤집힌 삼각형을 미리 표시하여 사용자가 직접 수정할 수 있도록 함
3. **개선 방향**: 
   - 폴리곤 표시 시 뒤집힌 삼각형 감지 및 시각화
   - `morph_face_by_landmarks()`에서 반복 검사 제거 또는 최소화

## 작업 계획

### 1. 폴리곤 표시 시 뒤집힌 삼각형 감지 기능 추가
- **위치**: `gui/face_edit/polygon_renderer.py` `_draw_landmark_polygons()` 함수
- **기능**:
  - 원본 랜드마크와 변형된 랜드마크(custom_landmarks)를 비교
  - Delaunay Triangulation 생성
  - 뒤집힌 삼각형 감지 (`_check_triangles_flipped` 함수 활용)
  - 뒤집힌 삼각형을 빨간색으로 표시
- **시각화**:
  - 정상 삼각형: 기존 색상 (녹색/노란색)
  - 뒤집힌 삼각형: 빨간색으로 강조 표시

### 2. morph_face_by_landmarks()에서 반복 검사 제거
- **위치**: `utils/face_morphing.py` `morph_face_by_landmarks()` 함수
- **변경 사항**:
  - 뒤집힌 삼각형 검사 반복 로직 제거 또는 최소화
  - 단순히 뒤집힌 삼각형이 있으면 경고만 출력하고 진행
  - 또는 뒤집힌 삼각형이 있으면 해당 포인트를 원본으로 복원
- **이유**: 사용자가 이미 폴리곤에서 뒤집힌 삼각형을 확인하고 수정했을 것으로 가정

### 3. 헬퍼 함수 추가
- **위치**: `gui/face_edit/polygon_renderer.py` 또는 `utils/face_morphing.py`
- **기능**: 
  - Delaunay Triangulation 생성
  - 뒤집힌 삼각형 감지
  - 뒤집힌 삼각형의 삼각형 인덱스 반환

## 작업 단계
- [x] 1. `_check_triangles_flipped` 함수를 polygon_renderer에서 사용할 수 있도록 import 또는 복사
- [x] 2. `_draw_landmark_polygons()`에서 원본/변형 랜드마크 비교 로직 추가
- [x] 3. 뒤집힌 삼각형 감지 및 시각화 구현 (`_draw_flipped_triangles()` 함수 추가)
- [x] 4. `morph_face_by_landmarks()`에서 반복 검사 로직 제거 (단순 경고 및 문제 포인트 복원으로 변경)
- [ ] 5. 테스트 및 검증

## 작업 완료 내역
- 2026-01-16 14:14: scipy, numpy import 추가
- 2026-01-16 14:14: `_draw_flipped_triangles()` 함수 추가 (뒤집힌 삼각형 감지 및 빨간색 표시)
- 2026-01-16 14:14: `_draw_landmark_polygons()`에 뒤집힌 삼각형 표시 로직 추가
- 2026-01-16 14:14: `morph_face_by_landmarks()`에서 반복 검사 로직 제거 (최대 12회 반복 → 1회 검사)
- 2026-01-16 14:20: 디버깅 코드 제거 (selected_point_indices 관련)
- 2026-01-16 14:20: 불필요한 로그 출력 제거 (삼각형 유효성 검사, 정변환 완료 등)
- 2026-01-16 14:20: 픽셀 처리 부분 벡터화 (좌표 계산, 가중치 계산 벡터화)

## 예상 효과
- **성능 향상**: 반복 검사 제거로 50-90% 성능 개선 예상
- **사용자 경험**: 뒤집힌 삼각형을 미리 확인하고 수정 가능
- **직관성**: 문제가 있는 삼각형을 시각적으로 확인 가능

## 주의사항
- 원본 랜드마크와 변형된 랜드마크가 모두 필요
- Delaunay Triangulation 생성 비용 고려 (캐싱 활용)
- 폴리곤 표시 시에만 감지하므로 성능 영향 최소화

---

## 추가 성능 최적화 (2026-01-16)

### 추가 문제 분석
1. **픽셀 단위 Python 반복문**: `morph_face_by_landmarks()`에서 각 픽셀마다 Python 반복문으로 bilinear interpolation 수행 (2891-2955줄) - 가장 큰 병목
2. **이미지 다운샘플링**: 600px로 제한되어 있지만 여전히 느릴 수 있음
3. **불필요한 로그 출력**: 디버깅 로그가 많아 성능에 영향
4. **디버깅 코드**: `selected_point_indices` 관련 디버깅 코드가 매번 실행됨 (2778-2786줄)

### 추가 최적화 계획

#### 4. 픽셀 처리 벡터화
- **위치**: `utils/face_morphing.py` 2891-2955줄
- **현재**: Python 반복문으로 각 픽셀마다 bilinear interpolation 수행
- **개선**: numpy 벡터 연산으로 변경하여 성능 향상
- **예상 효과**: 10-50배 성능 향상

#### 5. 이미지 다운샘플링 크기 조정
- **위치**: `utils/face_morphing.py` 2781줄
- **현재**: max_dimension = 600
- **변경**: 400-500px로 조정 (품질과 성능의 균형)
- **예상 효과**: 약 30-50% 성능 향상

#### 6. 불필요한 로그 출력 제거
- **위치**: `utils/face_morphing.py` 여러 위치
- **제거할 로그**:
  - 선택한 포인트 인덱스 매핑 로그 (2786줄)
  - 정변환 완료 로그 (2958줄) - 필요시에만 출력
  - 삼각형 유효성 검사 경고 로그 (2830, 2839, 2860, 2872, 2877줄) - 디버그 모드에서만
- **예상 효과**: 약 5-10% 성능 향상

#### 7. 디버깅 코드 최적화
- **위치**: `utils/face_morphing.py` 2778-2786줄
- **현재**: `selected_point_indices`가 있을 때마다 모든 삼각형을 검사
- **개선**: 조건부 실행 또는 제거
- **예상 효과**: 약 5% 성능 향상

### 추가 작업 단계
- [x] 4. 픽셀 처리 벡터화 (Python 반복문 → numpy 벡터 연산, 부분 벡터화)
- [ ] 5. 이미지 다운샘플링 크기 조정 (600px → 400-500px) - 유지
- [x] 6. 불필요한 로그 출력 제거
- [x] 7. 디버깅 코드 최적화

### 추가 예상 효과
- **전체 성능**: 약 50-200% 추가 개선 예상
- **가장 큰 효과**: 픽셀 처리 벡터화 (10-50배 향상)

---

## 추가 개선사항 추천 (2026-01-16)

### 발견된 추가 병목 지점

#### 8. 픽셀 처리 완전 벡터화
- **위치**: `utils/face_morphing.py` 2920-2948줄
- **현재**: 계산은 벡터화했지만 가중치 분배는 여전히 Python 반복문 사용
- **개선**: numpy의 `np.add.at()` 또는 `np.bincount()`를 사용하여 완전 벡터화
- **예상 효과**: 5-20배 추가 성능 향상
- **난이도**: 중간 (인덱싱 복잡도 고려 필요)

#### 9. UI 업데이트 최적화
- **위치**: `gui/face_edit/polygon_drag_handler.py` 255-259줄
- **현재**: `show_edited_preview()`와 `update_face_features_display()`가 항상 호출됨
- **개선**: 
  - `show_edited_preview()`: 이미지가 변경되었을 때만 호출
  - `update_face_features_display()`: 랜드마크 표시가 활성화되어 있을 때만 호출
- **예상 효과**: 약 20-40% 성능 향상 (UI 업데이트 시간 단축)

#### 10. Delaunay 캐시 개선
- **위치**: `utils/face_morphing.py` 2640-2656줄
- **현재**: 단순 FIFO 방식 (첫 번째 항목 제거)
- **개선**: 
  - LRU (Least Recently Used) 캐시 구현
  - 또는 더 효율적인 해시 키 사용 (튜플 해시 대신 더 빠른 방법)
- **예상 효과**: 약 5-10% 성능 향상 (캐시 히트율 향상)

#### 11. 이미지 리사이즈 캐싱
- **위치**: `gui/face_edit/preview.py` 364-369줄
- **현재**: 매번 이미지 리사이즈 수행
- **개선**: 
  - 동일한 크기 요청 시 캐시된 결과 재사용
  - 해시 키: (이미지 ID, display_width, display_height)
- **예상 효과**: 약 10-20% 성능 향상 (UI 반응성 향상)

#### 12. 메모리 사용 최적화
- **위치**: `utils/face_morphing.py` 여러 위치
- **현재**: 불필요한 배열 복사가 많음
- **개선**: 
  - `.copy()` 호출 최소화
  - in-place 연산 사용 가능한 곳에서 사용
  - 큰 배열은 필요할 때만 생성
- **예상 효과**: 약 10-30% 메모리 사용 감소 및 약간의 성능 향상

#### 13. 삼각형 처리 병렬화 (선택적)
- **위치**: `utils/face_morphing.py` 2840줄 이후
- **현재**: 삼각형을 순차적으로 처리
- **개선**: 
  - `multiprocessing` 또는 `concurrent.futures`를 사용하여 삼각형별 병렬 처리
  - 단, 메모리 공유 및 동기화 오버헤드 고려 필요
- **예상 효과**: 멀티코어 환경에서 2-4배 성능 향상 가능
- **난이도**: 높음 (동기화 및 메모리 관리 복잡)

#### 14. 조기 종료 최적화
- **위치**: `utils/face_morphing.py` 2840줄 이후
- **현재**: 모든 삼각형을 처리
- **개선**: 
  - 선택한 포인트 주변 삼각형만 처리 (selected_point_indices 활용)
  - 또는 변경된 랜드마크 주변만 처리
- **예상 효과**: 약 30-70% 성능 향상 (변경 범위가 작을 때)

### 우선순위 추천

**즉시 적용 권장 (높은 효과, 낮은 난이도)**:
1. **9. UI 업데이트 최적화** - 가장 쉬우면서 효과 큼
2. **11. 이미지 리사이즈 캐싱** - 구현 간단, 효과 좋음
3. **14. 조기 종료 최적화** - 선택한 포인트 주변만 처리

**중기 적용 권장 (높은 효과, 중간 난이도)**:
4. **8. 픽셀 처리 완전 벡터화** - 가장 큰 성능 향상 가능
5. **10. Delaunay 캐시 개선** - 캐시 효율성 향상

**장기 적용 검토 (효과는 크지만 복잡)**:
6. **12. 메모리 사용 최적화** - 메모리 제약 환경에서 유용
7. **13. 삼각형 처리 병렬화** - 멀티코어 환경에서만 효과적

### 예상 전체 효과
- **즉시 적용 항목만**: 약 50-130% 추가 성능 향상
- **모든 항목 적용 시**: 약 200-500% 성능 향상 가능
