"""폴리곤 데이터 관리 및 보관 방식 분석"""
print("=" * 80)
print("폴리곤 데이터 관리 및 보관 방식 분석")
print("=" * 80)

print("\n[1. Delaunay Triangulation 캐싱]")
print("위치: utils/face_morphing/constants.py")
print("  - 전역 변수: _delaunay_cache = {} (딕셔너리)")
print("  - 최대 크기: _delaunay_cache_max_size = 5")
print("  - 키: 원본 포인트 배열의 해시값 (hash(tuple(map(tuple, original_points_array))))")
print("  - 값: Delaunay Triangulation 객체 (scipy.spatial.Delaunay)")
print("  - 관리 방식: LRU (Least Recently Used) - 최대 크기 초과 시 가장 오래된 항목 제거")
print("  - 사용 위치: utils/face_morphing/polygon_morphing.py morph_face_by_polygons()")

print("\n[2. 폴리곤 포인트 관리 (GUI)]")
print("위치: gui/face_edit/__init__.py")
print("  - polygon_point_map: {'original': set(), 'edited': set()}")
print("    * 폴리곤 포인트 인덱스를 set으로 관리")
print("    * 원본/편집 캔버스별로 분리")
print("  - landmark_polygon_items: {'original': [], 'edited': []}")
print("    * 캔버스 아이템 ID를 리스트로 관리")
print("    * 원본/편집 캔버스별로 분리")

print("\n[3. 랜드마크 데이터 관리]")
print("위치: gui/face_edit/__init__.py")
print("  - original_landmarks: 원본 이미지의 랜드마크 (항상 보존)")
print("  - custom_landmarks: 사용자가 수정한 랜드마크 (드래그로 변경된 경우)")
print("  - transformed_landmarks: 변형된 랜드마크 (슬라이더 등으로 변형된 경우)")

print("\n[4. 폴리곤 데이터 구조 (모핑 시)]")
print("위치: utils/face_morphing/polygon_morphing.py morph_face_by_polygons()")
print("  - original_points_array: numpy array")
print("    * 원본 랜드마크 + 눈동자 중앙 포인트 + 경계 포인트")
print("  - transformed_points_array: numpy array")
print("    * 변환된 랜드마크 + 눈동자 중앙 포인트 + 경계 포인트")
print("  - tri: Delaunay Triangulation 객체")
print("    * tri.simplices: 삼각형 인덱스 배열 (각 삼각형은 3개 포인트 인덱스)")
print("    * tri.points: 포인트 좌표 배열")

print("\n[5. 데이터 흐름]")
print("1. 랜드마크 감지 → original_landmarks 저장")
print("2. 사용자 드래그 → custom_landmarks 업데이트")
print("3. 슬라이더 조정 → transformed_landmarks 생성")
print("4. 모핑 호출:")
print("   - original_landmarks → original_points_array (눈동자 처리 + 경계 추가)")
print("   - transformed_landmarks → transformed_points_array (눈동자 처리 + 경계 추가)")
print("   - original_points_array 해시로 캐시 확인")
print("   - 캐시 있으면 재사용, 없으면 Delaunay 생성 후 캐시 저장")
print("   - 삼각형 변환 수행")

print("\n[6. 캐시 키 생성 방식]")
print("  cache_key = hash(tuple(map(tuple, original_points_array)))")
print("  - 원본 포인트 배열을 튜플로 변환 후 해시")
print("  - 같은 포인트 배열이면 같은 해시값 (캐시 히트)")
print("  - 포인트가 변경되면 다른 해시값 (캐시 미스)")

print("\n[7. 문제점 및 개선 가능성]")
print("문제점:")
print("  1. 캐시 키가 원본 포인트만 사용 → 변환된 포인트 변경 시 캐시 재사용 불가")
print("  2. 캐시 크기가 5개로 작음 → 여러 얼굴 편집 시 캐시 미스 가능")
print("  3. LRU 방식이 단순함 → 실제 사용 빈도 고려 안 함")
print("  4. 폴리곤 포인트 인덱스와 랜드마크 인덱스 매핑이 명확하지 않음")
print("     (눈동자 포인트 제거 후 중앙 포인트 추가로 인덱스 변경)")

print("\n개선 가능성:")
print("  1. 캐시 키에 변환된 포인트도 포함? (하지만 변환은 매번 다르므로 의미 없음)")
print("  2. 캐시 크기 증가 (메모리 사용량 고려)")
print("  3. 실제 LRU 구현 (OrderedDict 사용)")
print("  4. 인덱스 매핑 테이블 명시적 관리")

print("\n" + "=" * 80)
print("결론")
print("=" * 80)
print("폴리곤 데이터는 다음과 같이 관리됨:")
print("  1. Delaunay Triangulation: 전역 캐시에 저장 (최대 5개)")
print("  2. 폴리곤 포인트 인덱스: GUI 클래스에서 set으로 관리")
print("  3. 랜드마크 데이터: GUI 클래스에서 리스트로 관리")
print("  4. 모핑 시: numpy array로 변환 후 Delaunay 수행")
print("\n현재 구조는 기본적으로 잘 작동하지만, 인덱스 매핑이 복잡함")
